VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "OrderContext"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

'@================================================================================
' Description
'@================================================================================
'
'

'@================================================================================
' Interfaces
'@================================================================================

Implements IStateChangeListener

'@================================================================================
' Events
'@================================================================================

Event Change(ev As ChangeEventData)

'@================================================================================
' Constants
'@================================================================================

Private Const ModuleName                As String = "OrderContext"

'@================================================================================
' Enums
'@================================================================================

'@================================================================================
' Types
'@================================================================================

'@================================================================================
' Member variables
'@================================================================================

Private mOrderManager                           As OrderManager
Private mGroupName                              As String
Private mRecoveryContextName                    As String
Private mName                                   As String

Private mSessionName                            As String

Private mContractFuture                         As IFuture
Private mContract                               As IContract
Private mDataSource                             As IMarketDataSource
Attribute mDataSource.VB_VarHelpID = -1
Private mOrderSubmitter                         As IOrderSubmitter
Private mOrderAuthoriser                        As IOrderAuthoriser
Private mAccumulatedBracketOrders               As BracketOrders
Private mAccumulatedOrders                      As Orders


Private mIsSimulated                            As Boolean

Private mActiveBracketOrders                    As BracketOrders
    ' this contains all bracket orders for which one or more orders are
    ' not yet complete (or not yet cancelled)
    
Private mClosedBracketOrders                    As BracketOrders
    ' this contains all bracket orders for which all orders have completed (or
    ' been cancelled)
    
Private mCompletedSize                          As Long
    ' the total Size for all completed bracket orders (may be non-zero if one
    ' or more completed bracket orders has no target or stop-loss orders)
    
Private mPermittedOrderProperties               As IPermittedOrderProperties

Private mEnabled                                As Boolean
Private mProviderIsReady                        As Boolean
Private mDataSourceIsReady                      As Boolean

Private mTemplateOrder                          As Order

Private mPreventUnprotectedPositions            As Boolean

Private mChangeListeners                        As New Listeners

Private mTimerList                              As TimerList

Private WithEvents mFutureWaiter                As FutureWaiter
Attribute mFutureWaiter.VB_VarHelpID = -1

Private mBracketOrderRecoveryController         As BracketOrderRecoveryCtlr

Private mOrderContextsRef                       As WeakReference

Private mTickSize                               As Double

Private mNotReadyMessage                        As String

Private mAccountDataProvider                    As IAccountDataProvider
Private mCurrencyConverter                      As ICurrencyConverter

Private mFixedAccountBalance                    As Double

'@================================================================================
' Class Event Handlers
'@================================================================================

Private Sub Class_Initialize()
Set mActiveBracketOrders = New BracketOrders
Set mClosedBracketOrders = New BracketOrders
Set mFutureWaiter = New FutureWaiter
mTickSize = -1
End Sub

Private Sub Class_Terminate()
Debug.Print "OrderContext terminated"
End Sub

'@================================================================================
' IStateChangeListener Interface Members
'@================================================================================

Private Sub IStateChangeListener_Change(ev As StateChangeEventData)
Const ProcName As String = "IStateChangeListener_Change"
On Error GoTo Err

If TypeOf ev.Source Is ICurrencyConverter Then fireChange OrderContextReadyStateChanged
    

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' mFutureWaiter Event Handlers
'@================================================================================

Private Sub mFutureWaiter_WaitCompleted(ev As FutureWaitCompletedEventData)
Const ProcName As String = "mFutureWaiter_WaitCompleted"
On Error GoTo Err

If Not ev.Future.IsAvailable Then Exit Sub

If TypeOf ev.Future.Value Is IContract Then
    setContract ev.Future.Value
    IsReadyTickSize
    fireChange OrderContextReadyStateChanged
ElseIf TypeOf ev.Future.Value Is Clock Then
    setTimerListFromSimulatedClock ev.Future.Value
    fireChange OrderContextReadyStateChanged
End If

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' Properties
'@================================================================================

Public Property Get ActiveBracketOrders() As BracketOrders
Set ActiveBracketOrders = mActiveBracketOrders
End Property

Public Property Get ActiveSize() As Long
Const ProcName As String = "ActiveSize"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    ActiveSize = ActiveSize + lBracketOrder.Size
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get CancelPending() As Boolean
Const ProcName As String = "CancelPending"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    If lBracketOrder.Cancel(pEvenIfFilled:=False) Then CancelPending = True
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get ClosedBracketOrders() As BracketOrders
Set ClosedBracketOrders = mClosedBracketOrders
End Property

Public Property Get CompletedSize() As Long
CompletedSize = mCompletedSize
End Property

Public Property Get RecoveryContextName() As String
RecoveryContextName = mRecoveryContextName
End Property

Public Property Get ContractFuture() As IFuture
Set ContractFuture = mContractFuture
End Property

Public Property Get DataSource() As IMarketDataSource
Set DataSource = mDataSource
End Property

Public Property Let Enabled(ByVal Value As Boolean)
Const ProcName As String = "Enabled"
On Error GoTo Err

If mEnabled = Value Then Exit Property

mEnabled = Value
fireChange OrderContextReadyStateChanged

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Friend Property Let FixedAccountBalance(ByVal Value As Double)
mFixedAccountBalance = Value
End Property

Friend Property Get GroupName() As String
GroupName = mGroupName
End Property

Friend Property Let IsAccountProviderReady(ByVal Value As Boolean)
Const ProcName As String = "isAccountProviderReady"
On Error GoTo Err

fireChange OrderContextReadyStateChanged

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get IsActive() As Boolean
IsActive = (mActiveBracketOrders.Count <> 0)
End Property

Friend Property Let IsDataSourceReady(ByVal Value As Boolean)
Const ProcName As String = "IsDataSourceReady"
On Error GoTo Err

If mDataSourceIsReady = Value Then Exit Property

mDataSourceIsReady = Value
fireChange OrderContextReadyStateChanged

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get IsDataSourceReady() As Boolean
IsDataSourceReady = mDataSourceIsReady
End Property

Friend Property Let IsProviderReady(ByVal Value As Boolean)
Const ProcName As String = "IsProviderReady"
On Error GoTo Err

If mProviderIsReady = Value Then Exit Property

mProviderIsReady = Value
If mProviderIsReady Then
    IsReadyTickSize
End If

fireChange OrderContextReadyStateChanged

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get IsProviderReady() As Boolean
IsProviderReady = mProviderIsReady
End Property

Public Property Get IsReady() As Boolean
If Not mProviderIsReady Then
    mNotReadyMessage = "Not ready to submit orders"
    Exit Function
ElseIf Not mEnabled Then
    mNotReadyMessage = "Not ready - order submission disabled"
    Exit Function
ElseIf mContract Is Nothing Then
    mNotReadyMessage = "Not ready - contract not yet resolved"
    Exit Function
ElseIf mTimerList Is Nothing Then
    mNotReadyMessage = "Not ready - awaiting clock info"
    Exit Function
Else
    mNotReadyMessage = ""
    IsReady = True
End If
End Property

Public Property Get IsSimulated() As Boolean
IsSimulated = mIsSimulated
End Property

Friend Property Get Name() As String
Name = mName
End Property

Public Property Get NotReadyMessage() As String
NotReadyMessage = mNotReadyMessage
End Property

Friend Property Get OrderManager() As OrderManager
Set OrderManager = mOrderManager
End Property

Public Property Get OrderSubmitter() As IOrderSubmitter
Set OrderSubmitter = mOrderSubmitter
End Property

Public Property Get PendingBuySize() As Long
Const ProcName As String = "PendingBuySize"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    If lBracketOrder.LongPosition Then PendingBuySize = PendingBuySize + lBracketOrder.PendingSize
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get PendingSellSize() As Long
Const ProcName As String = "PendingSellSize"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    If Not lBracketOrder.LongPosition Then PendingSellSize = PendingSellSize + lBracketOrder.PendingSize
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get PendingSize() As Long
Const ProcName As String = "PendingSize"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    PendingSize = PendingSize + lBracketOrder.PendingSize
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Friend Property Let PermittedOrderProperties(ByVal Value As IPermittedOrderProperties)
Set mPermittedOrderProperties = Value
End Property

Public Property Get PermittedOrderTifs() As Long
PermittedOrderTifs = mPermittedOrderProperties.PermittedOrderTifs
End Property

Public Property Get PermittedOrderTypes() As Long
PermittedOrderTypes = mPermittedOrderProperties.PermittedOrderTypes
End Property

Public Property Get PermittedStopTriggerMethods() As Long
PermittedStopTriggerMethods = mPermittedOrderProperties.PermittedStopTriggerMethods
End Property

Public Property Let PreventUnprotectedPositions( _
                ByVal Value As Boolean)
mPreventUnprotectedPositions = Value
End Property

Public Property Get PreventUnprotectedPositions() As Boolean
PreventUnprotectedPositions = mPreventUnprotectedPositions
End Property

Public Property Get Risk() As Currency
Const ProcName As String = "Risk"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    If lBracketOrder.Risk = MaxCurrency Then
        Risk = MaxCurrency
        Exit For
    End If
    Risk = Risk + lBracketOrder.Risk
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Friend Property Get ScopeName() As String
ScopeName = mBracketOrderRecoveryController.ScopeName
End Property

Public Property Get Size() As Long
Const ProcName As String = "Size"
On Error GoTo Err

Size = mCompletedSize

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    Size = Size + lBracketOrder.Size
Next

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get TemplateOrder() As IOrder
Set TemplateOrder = mTemplateOrder
End Property

Public Property Get TickSize() As Double
Assert mTickSize > 0#, "TickSize not yet available"
TickSize = mTickSize
End Property

Friend Property Get TimerList() As TimerList
Set TimerList = mTimerList
End Property

'@================================================================================
' Methods
'@================================================================================

Friend Sub ActivateBracketOrder( _
                ByVal pBracketOrder As BracketOrder)
Const ProcName As String = "ActivateBracketOrder"
On Error GoTo Err

If pBracketOrder.IsComplete Then
    NotifyBracketOrderClosed pBracketOrder
Else
    mActiveBracketOrders.Add pBracketOrder
    fireChange OrderContextActiveStateChanged
End If
pBracketOrder.Activate

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "AddChangeListener"
On Error GoTo Err

mChangeListeners.Add pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

''
' Creates a buy <code>BracketOrder</code>
'
' @return the <code>BracketOrder</code> object created
'
' @param number         quantity to buy
'       EntryType  the type of order to enter the position:
'           BracketEntryTypeMarket            a market order
'           BracketEntryTypeMarketOnOpen      a market on open order
'           BracketEntryTypeMarketOnClose     a market on close order
'           BracketEntryTypeMarketIfTouched   a market if touched order
'           BracketEntryTypeMarketToLimit     a market to limit order
'           BracketEntryTypeBid               a limit order at the current Bid
'           BracketEntryTypeAsk               a limit order at the current Ask
'           BracketEntryTypeLast              a limit order at the last Trade Price
'           BracketEntryTypeLimit             a limit order
'           BracketEntryTypeLimitOnOpen       a limit on open order
'           BracketEntryTypeLimitOnClose      a limit on close order
'           BracketEntryTypeLimitIfTouched    a limit if touched order
'           BracketEntryTypeStop              a stop order
'           BracketEntryTypeStopLimit         a stop limit order
' @param BuyPrice       the limit Price for a limit order (ignored for BracketEntryTypeBid,
'                       BracketEntryTypeAsk and BracketEntryTypeLast)
' @param BuyOffset      number of ticks to modify the BuyPrice. For example, to place an order
'                       one tick below the current Ask, use BracketEntryTypeAsk and set
'                       BuyOffset to -1
' @param TriggerPrice   used with BracketEntryTypeMarketIfTouched, BracketEntryTypeLimitIfTouched,
'                       BracketEntryTypeStop and BracketEntryTypeStopLimit to specify the Price
'                       at which the order is triggered
' @param StopLossType  the type of stop-loss order to place:
'           BracketStopLossTypeNone               no stop-loss order
'           OrderTypestop               use a stop order
'           OrderTypestopLimit          use a stop limit order
'           BracketStopLossTypeBid                use a stop order at the current Bid (see StopOffset)
'           BracketStopLossTypeAsk                use a stop order at the current Ask (see StopOffset)
'           BracketStopLossTypeLast               use a stop order at the last Trade Price (see StopOffset)
'           BracketStopLossTypeAuto               use a stop order at the fill Price for the
'                                           entry order (see StopOffset)
' @param StopPrice      the trigger Price for OrderTypestop and OrderTypestopLimit
' @param StopOffset     number of ticks to modify the StopPrice. For example, for a stop-loss
'                       order 4 ticks below the entry order fill Price, use BracketStopLossTypeAuto
'                       and set StopOffset to -4
' @param StopLimitPrice the limit Price for OrderTypestopLimit
' @param TargetType the type of target order to place:
'           BracketTargetTypeNone             no target order
'           BracketTargetTypeLimit            use a limit order
'           BracketTargetTypeLimitIfTouched   use a limit if touched order
'           BracketTargetTypeMarketIfTouched  use a market if touched order
'           BracketTargetTypeBid              use a limit order at the current Bid (see TargetOffset)
'           BracketTargetTypeAsk              use a limit order at the current Ask (see TargetOffset)
'           BracketTargetTypeLast             use a limit order at the last Trade Price (see TargetOffset)
'           BracketTargetTypeAuto             use a limit order at the fill Price for the
'                                           entry order (see TargetOffset)
' @param TargetPrice    the limit Price for the target order
' @param TargetOffset   number of ticks to modify the TargetPrice. For example, for a target
'                       order 10 ticks above the entry order fill Price, use BracketTargetTypeAuto
'                       and set TargetOffset to 10
' @param TargetTriggerPrice  the trigger Price for BracketTargetTypeLimitIfTouched and BracketTargetTypeMarketIfTouched
' @param CancelPrice    if the entry order is a limit order and market Price rises to this
'                       Price before the entry order is filled, then the order is cancelled.
'                       If the entry order is a stop or stop limit order and market Price
'                       falls to this Price before the entry order is filled, then the order
'                       is cancelled
' @param EntryTIF       specifies the time in force for the entry order
' @param StopTIF        specifies the time in force for the stop-loss order
' @param TargetTIF      specifies the time in force for the target order
'
' @see
'
'@/
Public Function Buy( _
    ByVal Number As Long, _
    ByVal pEntryOrder As IOrder, _
    Optional ByVal pStopLossOrder As IOrder, _
    Optional ByVal pTargetOrder As IOrder, _
    Optional ByVal EntryTIF As OrderTIFs = OrderTIFDay, _
    Optional ByVal StopTIF As OrderTIFs = OrderTIFGoodTillCancelled, _
    Optional ByVal TargetTIF As OrderTIFs = OrderTIFGoodTillCancelled, _
    Optional ByVal CancelPrice As Double, _
    Optional ByVal CancelAfter As Long) As IBracketOrder
Const ProcName As String = "Buy"
On Error GoTo Err

Set Buy = CreateBracketOrder(OrderActions. _
                            OrderActionBuy, _
                            Number, _
                            pEntryOrder, _
                            pStopLossOrder, _
                            pTargetOrder)

pEntryOrder.TimeInForce = EntryTIF
If Not pStopLossOrder Is Nothing Then pStopLossOrder.TimeInForce = StopTIF
If Not pTargetOrder Is Nothing Then pTargetOrder.TimeInForce = TargetTIF
Buy.CancelPrice = CancelPrice
Buy.CancelAfter = CancelAfter

ExecuteBracketOrder Buy, True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CalculateOffsettedPrice( _
                ByVal pPriceSpec As PriceSpecifier, _
                ByVal pSecType As SecurityTypes, _
                ByVal pOrderAction As OrderActions) As Double
Const ProcName As String = "CalculateOffsettedPrice"
On Error GoTo Err

Dim lBidPrice As Double: lBidPrice = MaxDouble
If mDataSource.HasCurrentTick(TickTypeBid) Then lBidPrice = getCurrentPrice(TickTypeBid)

Dim lAskPrice As Double: lAskPrice = MaxDouble
If mDataSource.HasCurrentTick(TickTypeAsk) Then lAskPrice = getCurrentPrice(TickTypeAsk)

Dim lTradePrice As Double: lTradePrice = MaxDouble
If mDataSource.HasCurrentTick(TickTypeTrade) Then lTradePrice = getCurrentPrice(TickTypeTrade)

Dim lOptionModelPrice As Double: lOptionModelPrice = MaxDouble
If mDataSource.HasCurrentTick(TickTypeOptionModelPrice) Then lOptionModelPrice = getCurrentPrice(TickTypeOptionModelPrice)

CalculateOffsettedPrice = gCalculateOffsettedPrice( _
                                pPriceSpec, _
                                pSecType, _
                                pOrderAction, _
                                mTickSize, _
                                lBidPrice, _
                                lAskPrice, _
                                lTradePrice, _
                                lOptionModelPrice)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function Cancel() As Boolean
Const ProcName As String = "Cancel"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder
For Each lBracketOrder In mActiveBracketOrders
    If lBracketOrder.Cancel(pEvenIfFilled:=True) Then Cancel = True
Next

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CloseOut() As TaskController
Const ProcName As String = "CloseOut"
On Error GoTo Err

Dim t As New CloseoutOrderContextTask

Set CloseOut = StartTask(New CloseoutOrderContextTask, PriorityNormal, , , Me)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateBuyBracketOrder( _
    ByVal Number As Long, _
    ByVal pEntryOrder As IOrder, _
    Optional ByVal pStopLossOrder As IOrder, _
    Optional ByVal pTargetOrder As IOrder) As IBracketOrder
Const ProcName As String = "CreateBuyBracketOrder"
On Error GoTo Err

Set CreateBuyBracketOrder = CreateBracketOrder( _
                                        OrderActions.OrderActionBuy, _
                                        Number, _
                                        pEntryOrder, _
                                        pStopLossOrder, _
                                        pTargetOrder)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateEntryOrder( _
                    ByVal pEntryType As OrderTypes, _
                    Optional ByVal pLimitPriceSpec As PriceSpecifier, _
                    Optional ByVal pTriggerPriceSpec As PriceSpecifier, _
                    Optional ByVal pOutsideRTH As Boolean = False) As IOrder
Const ProcName As String = "CreateEntryOrder"
On Error GoTo Err

AssertArgument gIsEntryOrderType(pEntryType), "Invalid entry order type"

Dim lOrder As IOrder
Set lOrder = NewOrder(pEntryType)

lOrder.LimitPriceSpec = pLimitPriceSpec
lOrder.TriggerPriceSpec = pTriggerPriceSpec
lOrder.IgnoreRegularTradingHours = pOutsideRTH

Select Case pEntryType
Case OrderTypeMarket
Case OrderTypeMarketOnOpen
Case OrderTypeMarketOnClose
Case OrderTypeMarketIfTouched
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeMarketToLimit
Case OrderTypeLimit
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case OrderTypeLimitOnOpen
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case OrderTypeLimitOnClose
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case OrderTypeLimitIfTouched
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeStop
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeStopLimit
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeTrail
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeTrailLimit
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case Else
    AssertArgument False, "Invalid entry order type"
End Select

Set CreateEntryOrder = lOrder

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateStopLossOrder( _
                    ByVal pStopLossType As OrderTypes, _
                    Optional ByVal pLimitPriceSpec As PriceSpecifier, _
                    Optional ByVal pTriggerPriceSpec As PriceSpecifier, _
                    Optional ByVal pOutsideRTH As Boolean = False) As IOrder
Const ProcName As String = "CreateStopLossOrder"
On Error GoTo Err

AssertArgument gIsStopLossOrderType(pStopLossType), "Invalid stop-loss order type"

Dim lOrder As IOrder
Set lOrder = NewOrder(pStopLossType)

lOrder.LimitPriceSpec = pLimitPriceSpec
lOrder.TriggerPriceSpec = pTriggerPriceSpec
lOrder.IgnoreRegularTradingHours = pOutsideRTH

Select Case pStopLossType
Case OrderTypeStop
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeStopLimit
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case OrderTypeTrail
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeTrailLimit
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
End Select

Set CreateStopLossOrder = lOrder

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateTargetOrder( _
                    ByVal pTargetType As OrderTypes, _
                    Optional ByVal pLimitPriceSpec As PriceSpecifier, _
                    Optional ByVal pTriggerPriceSpec As PriceSpecifier, _
                    Optional ByVal pOutsideRTH As Boolean = False) As IOrder
Const ProcName As String = "CreateTargetOrder"
On Error GoTo Err

AssertArgument gIsTargetOrderType(pTargetType), "Invalid target order type"

Dim lOrder As IOrder
Set lOrder = NewOrder(pTargetType)

lOrder.LimitPriceSpec = pLimitPriceSpec
lOrder.TriggerPriceSpec = pTriggerPriceSpec
lOrder.IgnoreRegularTradingHours = pOutsideRTH

Select Case pTargetType
Case OrderTypeLimit
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
Case OrderTypeLimitIfTouched
    AssertArgument pLimitPriceSpec.IsValid, "The limit price specification must be valid for this order type"
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
Case OrderTypeMarketIfTouched
    AssertArgument pTriggerPriceSpec.IsValid, "The trigger price specification must be valid for this order type"
End Select

Set CreateTargetOrder = lOrder

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateBracketOrder( _
                ByVal pAction As OrderActions, _
                ByVal pQuantity As Long, _
                ByVal pEntryOrder As IOrder, _
                Optional ByVal pStopLossOrder As IOrder, _
                Optional ByVal pTargetOrder As IOrder) As IBracketOrder
Const ProcName As String = "CreateBracketOrder"
On Error GoTo Err



Set CreateBracketOrder = CreateBracketOrderWithId( _
                            pAction, _
                            pQuantity, _
                            pEntryOrder, _
                            GIdProvider.gNextId, _
                            pStopLossOrder, _
                            pTargetOrder)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateBracketOrderWithId( _
                ByVal pAction As OrderActions, _
                ByVal pQuantity As Long, _
                ByVal pEntryOrder As IOrder, _
                ByVal pId As String, _
                Optional ByVal pStopLossOrder As IOrder, _
                Optional ByVal pTargetOrder As IOrder) As IBracketOrder
Const ProcName As String = "CreateBracketOrderWithId"
On Error GoTo Err

AssertArgument pQuantity > 0, "Quantity must be greater than zero"
AssertArgument Not pEntryOrder Is Nothing, "Entry order cannot be Nothing"
AssertArgument pId <> "", "Id must be supplied"

AssertArgument gIsEntryOrderType(pEntryOrder.OrderType), "Invalid entry order type"
If Not pStopLossOrder Is Nothing Then AssertArgument gIsStopLossOrderType(pStopLossOrder.OrderType), "Invalid stop-loss order type"
If Not pTargetOrder Is Nothing Then AssertArgument gIsTargetOrderType(pTargetOrder.OrderType), "Invalid target order type"

Dim lBracketOrder As New BracketOrder
lBracketOrder.Initialise pId, mRecoveryContextName, mGroupName, Me, mContract, mOrderSubmitter, mDataSource, mIsSimulated
lBracketOrder.PreventUnprotectedPosition = mPreventUnprotectedPositions

lBracketOrder.SetEntryOrder pEntryOrder
pEntryOrder.Action = pAction
lBracketOrder.EntryOrder.Quantity = pQuantity

If Not pStopLossOrder Is Nothing Then
    lBracketOrder.SetStopLossOrder pStopLossOrder
    lBracketOrder.StopLossOrder.Action = IIf(pAction = OrderActionBuy, OrderActionSell, OrderActionBuy)
    lBracketOrder.StopLossOrder.Quantity = pQuantity
End If

If Not pTargetOrder Is Nothing Then
    lBracketOrder.SetTargetOrder pTargetOrder
    lBracketOrder.TargetOrder.Action = IIf(pAction = OrderActionBuy, OrderActionSell, OrderActionBuy)
    lBracketOrder.TargetOrder.Quantity = pQuantity
End If

lBracketOrder.Checkpoint

Set CreateBracketOrderWithId = lBracketOrder

gLogBracketOrderMessage "Created bracket order: " & vbCrLf & _
                        lBracketOrder.ToString, _
                        mDataSource, _
                        mContract, _
                        lBracketOrder.Key, _
                        mIsSimulated, _
                        Me

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Function CreateRawOrder( _
                ByVal Id As String, _
                Optional ByVal pRecoveryContextName As String) As IOrder
Const ProcName As String = "CreateRawOrder"
On Error GoTo Err

Assert IsProviderReady, "The service provider is not Ready"

Dim lOrder As New Order
lOrder.Id = Id
Set CreateRawOrder = lOrder

If Not mAccumulatedOrders Is Nothing Then mAccumulatedOrders.Add lOrder

If pRecoveryContextName <> "" And Not mBracketOrderRecoveryController Is Nothing Then
    lOrder.RecoveryContextName = pRecoveryContextName
    Dim lObj As IRecoverable: Set lObj = lOrder
    lObj.AddRecoverableObjectListener mBracketOrderRecoveryController
End If
Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function CreateSellBracketOrder( _
    ByVal Number As Long, _
    ByVal pEntryOrder As IOrder, _
    Optional ByVal pStopLossOrder As IOrder, _
    Optional ByVal pTargetOrder As IOrder) As IBracketOrder
Const ProcName As String = "CreateSellBracketOrder"
On Error GoTo Err

Set CreateSellBracketOrder = CreateBracketOrder( _
                                        OrderActions.OrderActionSell, _
                                        Number, _
                                        pEntryOrder, _
                                        pStopLossOrder, _
                                        pTargetOrder)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Sub ExecuteBracketOrderEx(ByVal pBracketOrder As IBracketOrder, _
                    ByVal pCheckMoneyManagement As Boolean, _
                    ByVal pAddToActiveBracketOrders As Boolean)
Const ProcName As String = "ExecuteBracketOrderEx"
On Error GoTo Err

AssertArgument Not pBracketOrder Is Nothing, "No bracket order supplied"
Assert IsReadyForBracketOrder(pBracketOrder), _
        "The service provider is not Ready"

FixupEntryOrder pBracketOrder.EntryOrder
fixupStopLossOrder pBracketOrder.StopLossOrder
fixupTargetOrder pBracketOrder.TargetOrder

Dim msg As String
If TypeOf pBracketOrder Is IAutoSizingBracket Then
    Dim lBracketOrder As IAutoSizingBracket: Set lBracketOrder = pBracketOrder
    
    If lBracketOrder.AutosizeType = BracketAutosizeNone Then
    ElseIf mAccountDataProvider Is Nothing Then
        Assert False, "No account data provider has been configured"
    ElseIf lBracketOrder.AutosizeValue = 0 Then
        Assert False, "Invalid autosize value"
    ElseIf Not autoSize(lBracketOrder) Then
        Exit Sub
    End If
End If

If pCheckMoneyManagement And Not mIsSimulated Then
    Dim lOrigQuantity As Long
    lOrigQuantity = pBracketOrder.EntryOrder.Quantity
    
    Dim lNewQuantity As Long
    lNewQuantity = lOrigQuantity
    If Not mOrderAuthoriser Is Nothing Then
        If Not mOrderAuthoriser.AllowOrder( _
                                pBracketOrder, _
                                mTimerList.Clock.Timestamp, _
                                lNewQuantity, _
                                msg) _
        Then
            gLogBracketOrderMessage "Rejected by money management: " & msg, mDataSource, mContract, pBracketOrder.Key, mIsSimulated, Me
            pBracketOrder.Cancel
            Set pBracketOrder = Nothing
            Exit Sub
        End If
    End If
    If lNewQuantity <> lOrigQuantity Then
        gLogBracketOrderMessage "Order quantity adjusted by money management: " & _
                                "was " & lOrigQuantity & _
                                "; now " & lNewQuantity, _
                                mDataSource, _
                                mContract, _
                                pBracketOrder.Key, _
                                mIsSimulated, _
                                Me
        pBracketOrder.SetNewEntryQuantity lNewQuantity
        pBracketOrder.Update
    End If
End If

gLogBracketOrderMessage "Execute bracket order: " & vbCrLf & _
                        gBracketOrderToString(pBracketOrder), _
                        mDataSource, _
                        mContract, _
                        pBracketOrder.Key, _
                        mIsSimulated, _
                        Me

If pAddToActiveBracketOrders Then
    mActiveBracketOrders.Add pBracketOrder
End If

If Not mAccumulatedBracketOrders Is Nothing Then mAccumulatedBracketOrders.Add pBracketOrder
setOrderRecoveryForBracketOrder pBracketOrder

fireChange OrderContextActiveStateChanged
pBracketOrder.Execute

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub ExecuteBracketOrder(ByVal pBracketOrder As IBracketOrder, _
                    Optional pCheckMoneyManagement As Boolean)
Const ProcName As String = "ExecuteBracketOrder"
On Error GoTo Err

ExecuteBracketOrderEx pBracketOrder, pCheckMoneyManagement, True

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Function Finish()
Const ProcName As String = "Finish"
On Error GoTo Err

Dim lBracketOrder As BracketOrder

Set mDataSource = Nothing
For Each lBracketOrder In mActiveBracketOrders
    lBracketOrder.Finish
Next
Set mActiveBracketOrders = Nothing

For Each lBracketOrder In mClosedBracketOrders
    lBracketOrder.Finish
Next
Set mClosedBracketOrders = Nothing

Set mOrderSubmitter = Nothing

mNotReadyMessage = "Provider terminated"
fireChange OrderContextFinished

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Sub FixupEntryOrder(pOrder As Order)
Const ProcName As String = "fixupEntryOrder"
On Error GoTo Err

If pOrder Is Nothing Then Exit Sub

Dim lPriceDesc As String

Select Case pOrder.OrderType
Case OrderTypeMarket
Case OrderTypeMarketOnOpen
Case OrderTypeMarketOnClose
Case OrderTypeMarketIfTouched
    lPriceDesc = "trigger"
    pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                pOrder.TriggerPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeMarketToLimit
Case OrderTypeLimit
    lPriceDesc = "limit"
    pOrder.LimitPrice = CalculateOffsettedPrice( _
                                pOrder.LimitPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeLimitOnOpen
    lPriceDesc = "limit"
    pOrder.LimitPrice = CalculateOffsettedPrice( _
                                pOrder.LimitPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeLimitOnClose
    lPriceDesc = "limit"
    pOrder.LimitPrice = CalculateOffsettedPrice( _
                                pOrder.LimitPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeLimitIfTouched
    lPriceDesc = "limit"
    pOrder.LimitPrice = CalculateOffsettedPrice( _
                                pOrder.LimitPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
    lPriceDesc = "trigger"
    pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                pOrder.TriggerPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeStop, _
        OrderTypeTrail
    lPriceDesc = "trigger"
    pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                pOrder.TriggerPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
Case OrderTypeStopLimit, _
        OrderTypeTrailLimit
    lPriceDesc = "limit"
    pOrder.LimitPrice = CalculateOffsettedPrice( _
                                pOrder.LimitPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
    lPriceDesc = "trigger"
    pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                pOrder.TriggerPriceSpec, _
                                mContract.Specifier.SecType, _
                                pOrder.Action)
End Select

Exit Sub

Err:
If Err.Number = ErrorCodes.ErrIllegalArgumentException Then
    Err.Raise ErrorCodes.ErrIllegalArgumentException, _
                gGetSourceDesignator(ModuleName, ProcName), _
                "Entry " & lPriceDesc & " price: " & Err.Description
End If
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub Initialise( _
                ByVal pOrderContexts As OrderContexts, _
                ByVal pName As String, _
                ByVal pOrderManager As OrderManager, _
                ByVal pRecoveryContextName As String, _
                ByVal pGroupName As String, _
                ByVal pIsSimulated As Boolean, _
                ByVal pContractFuture As IFuture, _
                ByVal pDataSource As IMarketDataSource, _
                ByVal pOrderSubmitter As IOrderSubmitter, _
                ByVal pOrderAuthoriser As IOrderAuthoriser, _
                ByVal pAccumulatedBracketOrders As BracketOrders, _
                ByVal pAccumulatedOrders As Orders, _
                ByVal pSimulatedClockFuture As IFuture, _
                ByVal pBracketOrderRecoveryController As BracketOrderRecoveryCtlr, _
                ByVal pAccountDataProvider As IAccountDataProvider, _
                ByVal pCurrencyConverter As ICurrencyConverter)
Const ProcName As String = "Initialise"
On Error GoTo Err

Set mOrderContextsRef = CreateWeakReference(pOrderContexts)
mName = pName
Set mOrderManager = pOrderManager
mSessionName = mOrderManager.SessionName
mRecoveryContextName = pRecoveryContextName
mGroupName = pGroupName
mIsSimulated = pIsSimulated
Set mDataSource = pDataSource
Set mOrderSubmitter = pOrderSubmitter
Set mOrderAuthoriser = pOrderAuthoriser
Set mAccumulatedBracketOrders = pAccumulatedBracketOrders
Set mAccumulatedOrders = pAccumulatedOrders

Set mBracketOrderRecoveryController = pBracketOrderRecoveryController
Set mAccountDataProvider = pAccountDataProvider
Set mCurrencyConverter = pCurrencyConverter

Set mContractFuture = pContractFuture
If mContractFuture.IsAvailable Then
    setContract mContractFuture.Value
Else
    mFutureWaiter.Add mContractFuture
End If

If pSimulatedClockFuture Is Nothing Then
    Set mTimerList = GetGlobalTimerList
ElseIf pSimulatedClockFuture.IsAvailable Then
    setTimerListFromSimulatedClock pSimulatedClockFuture.Value
Else
    mFutureWaiter.Add pSimulatedClockFuture
End If


Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub


Public Function IsOrderAttributeSupported( _
                ByVal Value As OrderAttributes) As Boolean
Const ProcName As String = "IsOrderAttributeSupported"
On Error GoTo Err

Assert IsProviderReady, "OrderContext is not ready"
IsOrderAttributeSupported = ((mPermittedOrderProperties.PermittedOrderAttributes And Value) = Value)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsOrderTifSupported( _
                ByVal Value As OrderTIFs) As Boolean
Const ProcName As String = "IsOrderTifSupported"
On Error GoTo Err

Assert IsProviderReady, "OrderContext is not ready"
IsOrderTifSupported = ((mPermittedOrderProperties.PermittedOrderTifs And Value) = Value)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsOrderTypeSupported( _
                ByVal Value As OrderTypes) As Boolean
Const ProcName As String = "IsOrderTypeSupported"
On Error GoTo Err

Assert IsProviderReady, "OrderContext is not ready"
IsOrderTypeSupported = ((mPermittedOrderProperties.PermittedOrderTypes And Value) = Value)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsReadyForAutoSize( _
                ByVal pAutosizeType As BracketAutosizeTypes, _
                ByVal pCurrency As String) As Boolean
Const ProcName As String = "IsReadyForAutoSize"
On Error GoTo Err

IsReadyForAutoSize = True

If pAutosizeType = BracketAutosizeMonetaryAmount Or pAutosizeType = BracketAutosizePercentOfAccount Then
    If mDataSource.HasCurrentTick(TickTypeAsk) Then
    ElseIf mDataSource.HasCurrentTick(TickTypeBid) Then
    ElseIf mDataSource.HasCurrentTick(TickTypeTrade) Then
    Else
        IsReadyForAutoSize = False
    End If
End If

If pAutosizeType = BracketAutosizePercentOfAccount Then
    If Not IsAccountProviderReady Then IsReadyForAutoSize = False
    If Not mCurrencyConverter.IsReadyCurrencies(mAccountDataProvider.BaseCurrency, "USD") Then
        mCurrencyConverter.AddStateChangeListener mAccountDataProvider.BaseCurrency, "USD", Me
        IsReadyForAutoSize = False
    End If
    If Not mCurrencyConverter.IsReadyCurrencies(mContract.Specifier.CurrencyCode, "USD") Then
        mCurrencyConverter.AddStateChangeListener mContract.Specifier.CurrencyCode, "USD", Me
        IsReadyForAutoSize = False
    End If
End If

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsReadyForBracketOrder( _
                ByVal pBracketOrder As IBracketOrder) As Boolean
Const ProcName As String = "IsReadyForBracketOrder"
On Error GoTo Err

If Not IsReady Then Exit Function

If Not IsReadyTickSize() Then Exit Function

If TypeOf pBracketOrder Is IAutoSizingBracket Then
    Dim lBracket As IAutoSizingBracket: Set lBracket = pBracketOrder
    If Not IsReadyForAutoSize(lBracket.AutosizeType, pBracketOrder.Contract.Specifier.CurrencyCode) Then Exit Function
End If

If Not isReadyForOrder(pBracketOrder.EntryOrder) Then Exit Function

If Not pBracketOrder.StopLossOrder Is Nothing Then
    If Not isReadyForOrder(pBracketOrder.StopLossOrder) Then Exit Function
End If

If Not pBracketOrder.TargetOrder Is Nothing Then
    If Not isReadyForOrder(pBracketOrder.TargetOrder) Then Exit Function
End If

IsReadyForBracketOrder = True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsReadyForOrderType( _
                ByVal pOrderType As OrderTypes) As Boolean
Const ProcName As String = "IsReadyForOrderType"
On Error GoTo Err

IsReadyForOrderType = mOrderSubmitter.IsReadyForOrderType(pOrderType)
If IsReadyForOrderType Then
    mNotReadyMessage = ""
Else
    mNotReadyMessage = "Not ready for order type : " & gOrderTypeToShortString(pOrderType)
End If

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsReadyForPriceSpecifier(ByVal pPriceSpec As PriceSpecifier) As Boolean
Const ProcName As String = "IsReadyForPriceSpecifier"
On Error GoTo Err

mNotReadyMessage = ""

If pPriceSpec Is Nothing Then
    IsReadyForPriceSpecifier = True
    Exit Function
End If

IsReadyForPriceSpecifier = False

Select Case pPriceSpec.PriceType
Case PriceValueTypeAsk
    If Not mDataSource.HasCurrentTick(TickTypeAsk) Then
        mNotReadyMessage = "Not ready for ask price"
        Exit Function
    End If
Case PriceValueTypeBid
    If Not mDataSource.HasCurrentTick(TickTypeBid) Then
        mNotReadyMessage = "Not ready for bid price"
        Exit Function
    End If
Case PriceValueTypeLast
    If Not mDataSource.HasCurrentTick(TickTypeTrade) Then
        mNotReadyMessage = "Not ready for last price"
        Exit Function
    End If
Case PriceValueTypeModel
    If Not mDataSource.HasCurrentTick(TickTypeOptionModelPrice) Then
        mNotReadyMessage = "Not ready for option model price"
        Exit Function
    End If
Case PriceValueTypeMid, _
        PriceValueTypeBidOrAsk
    If Not mDataSource.HasCurrentTick(TickTypeAsk) Then
        mNotReadyMessage = "Not ready for ask price"
        Exit Function
    ElseIf Not mDataSource.HasCurrentTick(TickTypeBid) Then
        mNotReadyMessage = "Not ready for ask price"
        Exit Function
    End If
Case PriceValueTypeEntry
End Select

If pPriceSpec.OffsetType = PriceOffsetTypeBidAskPercent Then
    If Not mDataSource.HasCurrentTick(TickTypeAsk) Then
        mNotReadyMessage = "Not ready for ask price"
        Exit Function
    End If
    If Not mDataSource.HasCurrentTick(TickTypeBid) Then
        mNotReadyMessage = "Not ready for bid price"
        Exit Function
    End If
End If

IsReadyForPriceSpecifier = True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsReadyTickSize() As Boolean
Const ProcName As String = "IsReadyTickSize"
On Error GoTo Err

If mTickSize <> -1# Then
    mNotReadyMessage = ""
    IsReadyTickSize = True
ElseIf Not IsProviderReady Then
    mNotReadyMessage = "Not ready to submit orders"
    IsReadyTickSize = False
ElseIf getOrderContexts.IsGettingTickSize Then
    mNotReadyMessage = "Not ready: determining minimum price variation"
    IsReadyTickSize = False
ElseIf Not getOrderContexts.IsReadyTickSize Then
    mNotReadyMessage = "Not ready: determining minimum price variation"
    IsReadyTickSize = False
Else
    Assert False, "unexpected order context state"
End If

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Function IsStopTriggerMethodSupported( _
                ByVal Value As OrderStopTriggerMethods) As Boolean
Const ProcName As String = "IsStopTriggerMethodSupported"
On Error GoTo Err

Assert IsProviderReady, "OrderContext is not ready"
IsStopTriggerMethodSupported = ((mPermittedOrderProperties.PermittedStopTriggerMethods And Value) = Value)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Function NewExecution(ByVal pSetOrderRecovery As Boolean) As IExecutionReport
Const ProcName As String = "NewExecution"
On Error GoTo Err

Dim lExec As New Execution
If pSetOrderRecovery And Not mBracketOrderRecoveryController Is Nothing Then
    lExec.AddRecoverableObjectListener mBracketOrderRecoveryController
End If
lExec.GroupName = mGroupName

Set NewExecution = lExec

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Function NewOrder( _
                ByVal pOrderType As OrderTypes, _
                Optional ByVal pRecoveryContextName As String, _
                Optional ByVal pBasedOn As IOrder) As IOrder
Const ProcName As String = "NewOrder"
On Error GoTo Err

Dim lOrder As Order

If pBasedOn Is Nothing Then
    Set lOrder = mTemplateOrder.Clone
    lOrder.OrderType = pOrderType
    lOrder.Id = gNextId
Else
    Set lOrder = New Order
    lOrder.Initialise pBasedOn.GroupName, pBasedOn.ContractSpecifier, pBasedOn.OrderContext
    
    lOrder.DontCheckAttributeModificationPermitted = True
    lOrder.OrderType = pOrderType
    lOrder.Id = gNextId
    
    gSyncToOrder lOrder, pBasedOn
    
    lOrder.BrokerId = ""
    lOrder.ErrorCode = 0
    lOrder.ErrorMessage = ""
    lOrder.LimitPrice = MaxDoubleValue
    lOrder.Message = ""
    lOrder.FillTime = 0
    lOrder.LastFillPrice = 0#
    lOrder.QuantityFilled = 0
    lOrder.QuantityRemaining = lOrder.Quantity
    lOrder.Status = OrderStatusCreated
    lOrder.TriggerPrice = MaxDoubleValue
    lOrder.DontCheckAttributeModificationPermitted = False
End If


If Not mAccumulatedOrders Is Nothing Then mAccumulatedOrders.Add lOrder

If pRecoveryContextName <> "" And Not mBracketOrderRecoveryController Is Nothing Then
    lOrder.RecoveryContextName = pRecoveryContextName
    Dim lObj As IRecoverable: Set lObj = lOrder
    lObj.AddRecoverableObjectListener mBracketOrderRecoveryController
End If

Set NewOrder = lOrder

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Function NotifyBracketOrderClosed( _
                ByVal pBracketOrder As IBracketOrder)
Const ProcName As String = "NotifyBracketOrderClosed"
On Error GoTo Err

If mActiveBracketOrders.Contains(pBracketOrder) Then mActiveBracketOrders.Remove pBracketOrder

If Not mClosedBracketOrders.Contains(pBracketOrder.Key) Then
    mClosedBracketOrders.Add pBracketOrder
    mCompletedSize = mCompletedSize + pBracketOrder.Size
    ' now check if there are any active bracket orders left -
    If mActiveBracketOrders.Count = 0 Then fireChange OrderContextActiveStateChanged
End If
Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Sub NotifyDataReadinessChanged()
Const ProcName As String = "NotifyDataReadinessChanged"
On Error GoTo Err

IsReadyTickSize
fireChange OrderContextReadyStateChanged

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Function ParsePriceAndOffset( _
                ByRef pPriceSpec As PriceSpecifier, _
                ByVal pPriceString As String, _
                ByRef pMessage As String, _
                Optional ByVal pUseCloseoutSemantics As Boolean = False) As Boolean
Const ProcName As String = "ParsePriceAndOffset"
On Error GoTo Err

ParsePriceAndOffset = gParsePriceAndOffset( _
                                pPriceSpec, _
                                pPriceString, _
                                mContract.Specifier.SecType, _
                                mTickSize, _
                                pUseCloseoutSemantics, _
                                pMessage)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Sub RemoveChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "RemoveChangeListenerChangeListener"
On Error GoTo Err

mChangeListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Function Sell( _
    ByVal Number As Long, _
    ByVal pEntryOrder As IOrder, _
    Optional ByVal pStopLossOrder As IOrder, _
    Optional ByVal pTargetOrder As IOrder, _
    Optional ByVal EntryTIF As OrderTIFs = OrderTIFDay, _
    Optional ByVal StopTIF As OrderTIFs = OrderTIFGoodTillCancelled, _
    Optional ByVal TargetTIF As OrderTIFs = OrderTIFGoodTillCancelled, _
    Optional ByVal CancelPrice As Double, _
    Optional ByVal CancelAfter As Long) As IBracketOrder
Const ProcName As String = "Sell"
On Error GoTo Err

Set Sell = CreateBracketOrder(OrderActions.OrderActionSell, _
                                Number, _
                                pEntryOrder, _
                                pStopLossOrder, _
                                pTargetOrder)

pEntryOrder.TimeInForce = EntryTIF
If Not pStopLossOrder Is Nothing Then pStopLossOrder.TimeInForce = StopTIF
If Not pTargetOrder Is Nothing Then pTargetOrder.TimeInForce = TargetTIF
Sell.CancelPrice = CancelPrice
Sell.CancelAfter = CancelAfter

ExecuteBracketOrder Sell, True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Sub SetTickSize(ByVal pTickSize As Double)
Const ProcName As String = "SetTickSize"
On Error GoTo Err

mTickSize = pTickSize
If mTickSize > 0# Then fireChange OrderContextReadyStateChanged

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' Helper Functions
'@================================================================================

Private Function autoSize( _
                ByVal pBracketOrder As IAutoSizingBracket) As Boolean
Const ProcName As String = "autoSize"
On Error GoTo Err

Dim lBracketOrder As IBracketOrder: Set lBracketOrder = pBracketOrder

Dim lMessage As String
Dim lQuantity As Long

If pBracketOrder.AutosizeType = BracketAutosizeMonetaryAmount Then
    lQuantity = autoSizeAmount(pBracketOrder.AutosizeValue, _
                                pBracketOrder.LotSize, _
                                lBracketOrder.LongPosition, _
                                lMessage)
Else
    lQuantity = autoSizePercent(pBracketOrder.AutosizeValue, _
                                pBracketOrder.LotSize, _
                                lBracketOrder.LongPosition, _
                                lMessage)
End If

gLogBracketOrderMessage lMessage, _
                        mDataSource, _
                        mContract, _
                        lBracketOrder.Key, _
                        mIsSimulated, _
                        Me

If lQuantity <> 0 Then
    lBracketOrder.SetNewEntryQuantity lQuantity
    lBracketOrder.Update
    autoSize = True
Else
    lBracketOrder.Cancel
    autoSize = False
End If


Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function autoSizeAmount( _
                ByVal pAmount As Double, _
                ByVal pLotSize As Long, _
                ByVal pIsLong As Boolean, _
                ByRef pMessage As String) As Long
Const ProcName As String = "autoSizeAmount"
On Error GoTo Err

Dim lPrice As Double

If pIsLong Then
    If mDataSource.HasCurrentTick(TickTypeAsk) Then
        lPrice = mDataSource.CurrentTick(TickTypeAsk).Price
    ElseIf mDataSource.HasCurrentTick(TickTypeTrade) Then
        lPrice = mDataSource.CurrentTick(TickTypeTrade).Price
    ElseIf mDataSource.HasCurrentTick(TickTypeBid) Then
        lPrice = mDataSource.CurrentTick(TickTypeBid).Price
    End If
Else
    If mDataSource.HasCurrentTick(TickTypeBid) Then
        lPrice = mDataSource.CurrentTick(TickTypeBid).Price
    ElseIf mDataSource.HasCurrentTick(TickTypeTrade) Then
        lPrice = mDataSource.CurrentTick(TickTypeTrade).Price
    ElseIf mDataSource.HasCurrentTick(TickTypeAsk) Then
        lPrice = mDataSource.CurrentTick(TickTypeAsk).Price
    End If
End If

Dim lQuantity As Long
If lPrice = 0 Then
    pMessage = "No price currently available to size order"
    autoSizeAmount = 0
Else
    lQuantity = Int(pAmount / (mContract.Specifier.Multiplier * lPrice))
    If pLotSize <> 0 Then lQuantity = pLotSize * Int(lQuantity / pLotSize)
    
    If lQuantity <> 0 Then
        pMessage = "Order quantity set to " & lQuantity
    Else
        pMessage = "Order quantity reduced to 0 due to lack of funds"
    End If
End If

autoSizeAmount = lQuantity

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function autoSizePercent( _
                ByVal pPercent As Double, _
                ByVal pLotSize As Long, _
                ByVal pIsLong As Boolean, _
                ByRef pMessage As String) As Long
Const ProcName As String = "autoSizePercent"
On Error GoTo Err

Dim lAccountBalance As Double
If mFixedAccountBalance <> 0# Then
    lAccountBalance = mFixedAccountBalance
Else
    lAccountBalance = CDbl(mAccountDataProvider.GetAccountValue("NetLiquidation", mAccountDataProvider.BaseCurrency).Value)
End If

If mContract.Specifier.CurrencyCode <> mAccountDataProvider.BaseCurrency Then
    If mAccountDataProvider.BaseCurrency <> "USD" Then
        lAccountBalance = mCurrencyConverter.Convert(lAccountBalance, mAccountDataProvider.BaseCurrency, "USD")
    End If
    If mContract.Specifier.CurrencyCode <> "USD" Then
        lAccountBalance = mCurrencyConverter.Convert(lAccountBalance, "USD", mContract.Specifier.CurrencyCode)
    End If
End If

Dim lAmount As Double
lAmount = Int(pPercent * lAccountBalance / 100#)
autoSizePercent = autoSizeAmount(lAmount, pLotSize, pIsLong, pMessage)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub fireChange(ByVal pChangeType As OrderContextChangeTypes)
Const ProcName As String = "fireChange"
On Error GoTo Err

Dim ev As ChangeEventData
Set ev.Source = Me
ev.changeType = pChangeType

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mChangeListeners.Valid Then
    sInit = True
    sSomeListeners = mChangeListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IChangeListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.Change ev
    Next
End If

RaiseEvent Change(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fixupStopLossOrder(pOrder As Order)
Const ProcName As String = "fixupStopLossOrder"
On Error GoTo Err

If pOrder Is Nothing Then Exit Sub

Dim lPriceDesc As String

Select Case pOrder.OrderType
Case OrderTypeStop, _
        OrderTypeTrail
    lPriceDesc = "trigger"
    If pOrder.TriggerPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                    pOrder.TriggerPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
Case OrderTypeStopLimit, _
        OrderTypeTrailLimit
    lPriceDesc = "limit"
    If pOrder.LimitPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.LimitPrice = CalculateOffsettedPrice( _
                                    pOrder.LimitPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
    
    lPriceDesc = "trigger"
    If pOrder.TriggerPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                    pOrder.TriggerPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
End Select

Exit Sub

Err:
If Err.Number = ErrorCodes.ErrIllegalArgumentException Then
    Err.Raise ErrorCodes.ErrIllegalArgumentException, _
                gGetSourceDesignator(ModuleName, ProcName), _
                "Entry " & lPriceDesc & " price: " & Err.Description
End If
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fixupTargetOrder(pOrder As Order)
Const ProcName As String = "fixupTargetOrder"
On Error GoTo Err

If pOrder Is Nothing Then Exit Sub

Dim lPriceDesc As String

Select Case pOrder.OrderType
Case OrderTypeLimit, _
        OrderTypeLimitOnClose, _
        OrderTypeLimitOnOpen
    lPriceDesc = "limit"
    If pOrder.LimitPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.LimitPrice = CalculateOffsettedPrice( _
                                    pOrder.LimitPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
Case OrderTypeLimitIfTouched
    lPriceDesc = "limit"
    If pOrder.LimitPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.LimitPrice = CalculateOffsettedPrice( _
                                    pOrder.LimitPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
    lPriceDesc = "trigger"
    If pOrder.TriggerPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                    pOrder.TriggerPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
Case OrderTypeMarketIfTouched
    lPriceDesc = "trigger"
    If pOrder.TriggerPriceSpec.PriceType <> PriceValueTypeEntry Then
        pOrder.TriggerPrice = CalculateOffsettedPrice( _
                                    pOrder.TriggerPriceSpec, _
                                    mContract.Specifier.SecType, _
                                    pOrder.Action)
    End If
Case OrderTypeMarketOnClose, _
        OrderTypeMarketOnOpen
End Select

Exit Sub

Err:
If Err.Number = ErrorCodes.ErrIllegalArgumentException Then
    Err.Raise ErrorCodes.ErrIllegalArgumentException, _
                gGetSourceDesignator(ModuleName, ProcName), _
                "Entry " & lPriceDesc & " price: " & Err.Description
End If
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function getCurrentPrice(ByVal pTickType As TickTypes) As Double
Const ProcName As String = "getCurrentPrice"
On Error GoTo Err

If isDataSourceRunning Then getCurrentPrice = mDataSource.CurrentTick(pTickType).Price

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function getOrderContexts() As OrderContexts
Set getOrderContexts = mOrderContextsRef.Target
End Function

Private Property Get IsAccountProviderReady() As Boolean
IsAccountProviderReady = (mAccountDataProvider.State = AccountProviderReady)
End Property

Private Function isDataSourceRunning()
If mDataSource Is Nothing Then
    isDataSourceRunning = False
Else
    isDataSourceRunning = (mDataSource.State = MarketDataSourceStateRunning)
End If
End Function

Private Function isReadyForOrder( _
                ByVal pOrder As IOrder) As Boolean
Const ProcName As String = "isReadyForOrder"
On Error GoTo Err

If Not IsReadyForOrderType(pOrder.OrderType) Then Exit Function
If Not IsReadyForPriceSpecifier(pOrder.LimitPriceSpec) Then Exit Function
If Not IsReadyForPriceSpecifier(pOrder.TriggerPriceSpec) Then Exit Function

isReadyForOrder = True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub setContract(ByVal pContract As IContract)
Const ProcName As String = "setContract"
On Error GoTo Err

Set mContract = pContract
Set mTemplateOrder = New Order
mTemplateOrder.RecoveryContextName = mRecoveryContextName
mTemplateOrder.Initialise mGroupName, mContract.Specifier, Me
mTemplateOrder.IsSimulated = mIsSimulated

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub setOrderRecoveryForBracketOrder(ByVal pBracketOrder As IBracketOrder)
Const ProcName As String = "setOrderRecoveryForBracketOrder"
On Error GoTo Err

If mBracketOrderRecoveryController Is Nothing Then Exit Sub

Dim lObj As IRecoverable
Set lObj = pBracketOrder
lObj.AddRecoverableObjectListener mBracketOrderRecoveryController

Set lObj = pBracketOrder.EntryOrder
If Not lObj Is Nothing Then lObj.AddRecoverableObjectListener mBracketOrderRecoveryController

Set lObj = pBracketOrder.StopLossOrder
If Not lObj Is Nothing Then lObj.AddRecoverableObjectListener mBracketOrderRecoveryController

Set lObj = pBracketOrder.TargetOrder
If Not lObj Is Nothing Then lObj.AddRecoverableObjectListener mBracketOrderRecoveryController

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub setTimerListFromSimulatedClock(ByVal pClock As Clock)
Const ProcName As String = "setTimerListFromSimulatedClock"
On Error GoTo Err

Assert pClock.IsSimulated, "Not a simulated clock"
Set mTimerList = GetSimulatedTimerList(pClock)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

