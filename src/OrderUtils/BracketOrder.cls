VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "BracketOrder"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

'@================================================================================
' Description
'@================================================================================
'
'

'@================================================================================
' Interfaces
'@================================================================================

Implements IAutoSizingBracket
Implements IBracketOrder
Implements IChangeListener
Implements IRecoverable
Implements IStateChangeListener
Implements IStringable

'@================================================================================
' Events
'@================================================================================

Event Change(ByRef ev As ChangeEventData)
Event ChangesApplied()
Event ChangesCancelled()
Event ChangesPending()
Event CloseoutOrderChanged()
Event CloseoutOrderCreated()
Event CloseoutOrderFilled()
Event Completed()
Event EntryOrderChanged()
Event EntryOrderFilled()
Event Execution(ByRef ev As ExecutionEventData)
Event OrderError(ByRef ev As BracketOrderErrorEventData)
Event OrderMessage(ByRef ev As BracketOrderMessageEventData)
Event PositionCloseoutNotified()
Event SelfCancelled()
Event SizeChanged()
Event StateChange(ByRef ev As StateChangeEventData)
Event StopLossOrderChanged()
Event StopLossOrderFilled()
Event TargetOrderChanged()
Event TargetOrderFilled()

'@================================================================================
' Constants
'@================================================================================

Private Const ModuleName                As String = "BracketOrder"

'@================================================================================
' Enums
'@================================================================================

'@================================================================================
' Types
'@================================================================================

'@================================================================================
' Member variables
'@================================================================================

Private mSummary                                    As BOS

Private mRecoveryContextName                        As String

Private mOrderContext                               As OrderContext
Private mContract                                   As IContract
Private mDataSource                                 As IMarketDataSource
Private mOrderSubmitter                             As IOrderSubmitter
Private mTimerList                                  As TimerList
Private mClock                                      As Clock

Private mStateEngine                                As StateEngine

Private mCancelAfter                                As Long
Private WithEvents mCancelTLI                       As TimerListItem
Attribute mCancelTLI.VB_VarHelpID = -1

Private WithEvents mForceCloseTLI                   As TimerListItem
Attribute mForceCloseTLI.VB_VarHelpID = -1
Private WithEvents mDelayedCloseoutTLI              As TimerListItem
Attribute mDelayedCloseoutTLI.VB_VarHelpID = -1

Private WithEvents mEntryOrder                      As Order
Attribute mEntryOrder.VB_VarHelpID = -1
Private mEntryOrderCopy                             As Order

Private WithEvents mStopLossOrder                   As Order
Attribute mStopLossOrder.VB_VarHelpID = -1
Private mStopOrderCopy                              As Order
Attribute mStopOrderCopy.VB_VarHelpID = -1

Private WithEvents mTargetOrder                     As Order
Attribute mTargetOrder.VB_VarHelpID = -1
Private mTargetOrderCopy                            As Order
Attribute mTargetOrderCopy.VB_VarHelpID = -1

Private WithEvents mCloseoutOrder                   As Order
Attribute mCloseoutOrder.VB_VarHelpID = -1

Private mNewEntryQuantity                           As BoxedDecimal
Private mNewStopLossQuantity                        As BoxedDecimal
Private mNewTargetQuantity                          As BoxedDecimal

Private mNewEntryLimitPriceSpec                     As PriceSpecifier
Private mNewEntryTriggerPriceSpec                   As PriceSpecifier

Private mNewStopLossLimitPriceSpec                  As PriceSpecifier
Private mNewStopLossTriggerPriceSpec                As PriceSpecifier

Private mNewTargetLimitPriceSpec                    As PriceSpecifier
Private mNewTargetTriggerPriceSpec                  As PriceSpecifier

Private mIsSimulated                                As Boolean

Private mChangeListeners                            As New Listeners
Private mStateChangeListeners                       As New Listeners
Private mRecoverableObjectListeners                 As New Listeners
Private mExecutionListeners                         As New Listeners
Private mBracketOrderErrorListeners                 As New Listeners
Private mBracketOrderMessageListeners               As New Listeners

Private mApplicationIndex                           As Long

Private mIsDirty                                    As Boolean

Private mNumberOfOrders                             As Long

Private WithEvents mStateTimeoutTLI                 As TimerListItem
Attribute mStateTimeoutTLI.VB_VarHelpID = -1

Private WithEvents mRolloverTLI                     As TimerListItem
Attribute mRolloverTLI.VB_VarHelpID = -1

Private mNextBracketOrder                           As IBracketOrder
Private mNextContract                               As IContract

Private mRolloverController                         As RolloverController
Private mIsRolloverInProgress                       As Boolean

'@================================================================================
' Class Event Handlers
'@================================================================================

Private Sub Class_Initialize()
Const ProcName As String = "Class_Initialize"
On Error GoTo Err

Set mNewEntryQuantity = Nothing
Set mNewStopLossQuantity = Nothing
Set mNewTargetQuantity = Nothing

Set mNewEntryLimitPriceSpec = gNewPriceSpecifier
Set mNewEntryTriggerPriceSpec = gNewPriceSpecifier

Set mNewStopLossLimitPriceSpec = gNewPriceSpecifier
Set mNewStopLossTriggerPriceSpec = gNewPriceSpecifier

Set mNewTargetLimitPriceSpec = gNewPriceSpecifier
Set mNewTargetTriggerPriceSpec = gNewPriceSpecifier

Set mSummary = New BOS

mApplicationIndex = GBracketOrder.gNextApplicationIndex

Set mStateEngine = CreateStateEngine(GBracketOrder.TableBuilder, _
                                    BracketOrderStates.BracketOrderStateCreated)

mSummary.State = State

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub Class_Terminate()
Debug.Print "BracketOrder terminated"
End Sub

'@================================================================================
' IAutoSizingBracket Interface Members
'@================================================================================

Private Property Get IAutoSizingBracket_AutosizeType() As BracketAutosizeTypes
IAutoSizingBracket_AutosizeType = AutosizeType
End Property

Private Property Get IAutoSizingBracket_AutosizeValue() As Double
IAutoSizingBracket_AutosizeValue = AutosizeValue
End Property

Private Property Get IAutoSizingBracket_LotSize() As Long
IAutoSizingBracket_LotSize = LotSize
End Property

'@================================================================================
' IBracketOrder Interface Members
'@================================================================================

Private Sub IBracketOrder_AddBracketOrderErrorListener(ByVal pListener As IBracketOrderErrorListener)
AddBracketOrderErrorListener pListener
End Sub

Private Sub IBracketOrder_AddBracketOrderMessageListener(ByVal pListener As IBracketOrderMsgListener)
AddBracketOrderMessageListener pListener
End Sub

Private Sub IBracketOrder_AddChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "IBracketOrder_AddChangeListener"
On Error GoTo Err

AddChangeListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_AddExecutionListener(ByVal pListener As IExecutionListener)
Const ProcName As String = "IBracketOrder_AddExecutionListener"
On Error GoTo Err

AddExecutionListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_AddStateChangeListener(ByVal pListener As IStateChangeListener)
Const ProcName As String = "IBracketOrder_AddStateChangeListener"
On Error GoTo Err

AddStateChangeListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_AdjustStop( _
                ByVal pStopTriggerPriceSpec As PriceSpecifier, _
                Optional ByVal pQuantity As BoxedDecimal)
Const ProcName As String = "IBracketOrder_AdjustStop"
On Error GoTo Err

AdjustStopLoss pStopTriggerPriceSpec, pQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_AdjustTarget( _
                ByVal pTargetPriceSpec As PriceSpecifier, _
                Optional ByVal pQuantity As BoxedDecimal)
Const ProcName As String = "IBracketOrder_AdjustTarget"
On Error GoTo Err

AdjustTarget pTargetPriceSpec, pQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_ApplicationIndex() As Long
IBracketOrder_ApplicationIndex = ApplicationIndex
End Property

Private Function IBracketOrder_Cancel(Optional ByVal pEvenIfFilled As Boolean = False) As Boolean
Const ProcName As String = "IBracketOrder_Cancel"
On Error GoTo Err

IBracketOrder_Cancel = Cancel(pEvenIfFilled)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Property Let IBracketOrder_CancelAfter(ByVal Value As Long)
Const ProcName As String = "IBracketOrder_CancelAfter"
On Error GoTo Err

CancelAfter = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Sub IBracketOrder_CancelChanges()
Const ProcName As String = "IBracketOrder_CancelChanges"
On Error GoTo Err

CancelChanges

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Let IBracketOrder_CancelPrice(ByVal Value As Double)
Const ProcName As String = "IBracketOrder_CancelPrice"
On Error GoTo Err

CancelPrice = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Get IBracketOrder_CancelPrice() As Double
IBracketOrder_CancelPrice = CancelPrice
End Property

Private Property Let IBracketOrder_CancelTime(ByVal Value As Date)
Const ProcName As String = "IBracketOrder_CancelTime"
On Error GoTo Err

CancelTime = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Get IBracketOrder_CancelTime() As Date
IBracketOrder_CancelTime = CancelTime
End Property

Private Sub IBracketOrder_Checkpoint()
Const ProcName As String = "IBracketOrder_Checkpoint"
On Error GoTo Err

Checkpoint

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_CloseOut( _
                Optional ByVal pCloseoutSpec As CloseoutSpecifier)
Const ProcName As String = "IBracketOrder_CloseOut"
On Error GoTo Err

CloseOut pCloseoutSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_CloseoutOrder() As IOrder
Set IBracketOrder_CloseoutOrder = mCloseoutOrder
End Property

Private Function IBracketOrder_ContainsOrder(ByVal pOrder As IOrder) As Boolean
Const ProcName As String = "IBracketOrder_ContainsOrder"
On Error GoTo Err

IBracketOrder_ContainsOrder = ContainsOrder(pOrder)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Property Get IBracketOrder_ContextName() As String
IBracketOrder_ContextName = mSummary.ContextName
End Property

Private Property Get IBracketOrder_Contract() As IContract
Set IBracketOrder_Contract = mContract
End Property

Private Property Get IBracketOrder_CreationTime() As Date
IBracketOrder_CreationTime = CreationTime
End Property

Private Property Get IBracketOrder_CumBuyPrice() As BoxedDecimal
Set IBracketOrder_CumBuyPrice = CumBuyPrice
End Property

Private Property Get IBracketOrder_CumSellPrice() As BoxedDecimal
Set IBracketOrder_CumSellPrice = CumSellPrice
End Property

Private Property Let IBracketOrder_Description(ByVal RHS As String)
Description = RHS
End Property

Private Property Get IBracketOrder_Description() As String
IBracketOrder_Description = Description
End Property

Private Property Get IBracketOrder_EndTime() As Date
IBracketOrder_EndTime = EndTime
End Property

Private Property Get IBracketOrder_EntryOrder() As IOrder
Set IBracketOrder_EntryOrder = mEntryOrder
End Property

Private Property Get IBracketOrder_EntryPrice() As Double
IBracketOrder_EntryPrice = EntryPrice
End Property

Private Property Let IBracketOrder_EntryReason(ByVal RHS As String)
EntryReason = RHS
End Property

Private Property Get IBracketOrder_EntryReason() As String
IBracketOrder_EntryReason = EntryReason
End Property

Private Sub IBracketOrder_Execute()
Const ProcName As String = "IBracketOrder_Execute"
On Error GoTo Err

Execute

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_ExitPrice() As Double
IBracketOrder_ExitPrice = ExitPrice
End Property

Private Property Get IBracketOrder_GroupName() As String
IBracketOrder_GroupName = GroupName
End Property

Private Property Get IBracketOrder_IsComplete() As Boolean
Const ProcName As String = "IBracketOrder_IsComplete"
On Error GoTo Err

IBracketOrder_IsComplete = IsComplete

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Get IBracketOrder_IsDirty() As Boolean
IBracketOrder_IsDirty = IsDirty
End Property

Private Property Get IBracketOrder_IsSimulated() As Boolean
IBracketOrder_IsSimulated = IsSimulated
End Property

Private Property Get IBracketOrder_Key() As String
IBracketOrder_Key = mSummary.Key
End Property

Private Property Get IBracketOrder_LongPosition() As Boolean
IBracketOrder_LongPosition = LongPosition
End Property

Private Sub IBracketOrder_NotifyCloseout( _
                ByVal pExec As IExecutionReport)
Const ProcName As String = "IBracketOrder_NotifyCloseout"
On Error GoTo Err

NotifyCloseout pExec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_Order(ByVal pRole As BracketOrderRoles) As IOrder
Const ProcName As String = "IBracketOrder_Order"
On Error GoTo Err

Set IBracketOrder_Order = Order(pRole)

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Get IBracketOrder_OrderContext() As OrderContext
Set IBracketOrder_OrderContext = OrderContext
End Property

Private Property Get IBracketOrder_PendingSize() As BoxedDecimal
Const ProcName As String = "IBracketOrder_PendingSize"
On Error GoTo Err

Set IBracketOrder_PendingSize = PendingSize

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Let IBracketOrder_PreventUnprotectedPosition(ByVal Value As Boolean)
Const ProcName As String = "IBracketOrder_PreventUnprotectedPosition"
On Error GoTo Err

PreventUnprotectedPosition = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Private Property Get IBracketOrder_PreventUnprotectedPosition() As Boolean
IBracketOrder_PreventUnprotectedPosition = PreventUnprotectedPosition
End Property

Private Sub IBracketOrder_RemoveBracketOrderErrorListener(ByVal pListener As IBracketOrderErrorListener)
RemoveBracketOrderErrorListener pListener
End Sub

Private Sub IBracketOrder_RemoveBracketOrderMessageListener(ByVal pListener As IBracketOrderMsgListener)
RemoveBracketOrderMessageListener pListener
End Sub

Private Sub IBracketOrder_RemoveChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "IBracketOrder_RemoveChangeListener"
On Error GoTo Err

RemoveChangeListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_RemoveExecutionListener(ByVal pListener As IExecutionListener)
Const ProcName As String = "IBracketOrder_RemoveExecutionListener"
On Error GoTo Err

RemoveExecutionListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_RemoveStateChangeListener(ByVal pListener As IStateChangeListener)
Const ProcName As String = "IBracketOrder_RemoveStateChangeListener"
On Error GoTo Err

RemoveStateChangeListener pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_Risk() As Currency
IBracketOrder_Risk = Risk
End Property

Private Property Let IBracketOrder_RolloverSpecification(ByVal Value As RolloverSpecification)
RolloverSpecification = Value
End Property

Private Property Get IBracketOrder_RolloverSpecification() As RolloverSpecification
Set IBracketOrder_RolloverSpecification = RolloverSpecification
End Property

Private Sub IBracketOrder_SetNewEntryLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewEntryLimitPrice"
On Error GoTo Err

SetNewEntryLimitPrice pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewEntryTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewEntryTriggerPrice"
On Error GoTo Err

SetNewEntryTriggerPrice pPriceSpec


Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewOrderLimitPrice( _
                ByVal pRole As BracketOrderRoles, _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewOrderPrice"
On Error GoTo Err

SetNewOrderLimitPrice pRole, pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewOrderTriggerPrice( _
                ByVal pRole As BracketOrderRoles, _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewOrderTriggerPrice"
On Error GoTo Err

SetNewOrderTriggerPrice pRole, pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewEntryQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "IBracketOrder_SetNewEntryQuantity"
On Error GoTo Err

SetNewEntryQuantity pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewStopLossLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewStopLossPrice"
On Error GoTo Err

SetNewStopLossLimitPrice pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewStopLossQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "IBracketOrder_SetNewStopLossQuantity"
On Error GoTo Err

SetNewStopLossQuantity pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewStopLossTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewStopLossTriggerPrice"
On Error GoTo Err

SetNewStopLossTriggerPrice pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewTargetLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewTargetPrice"
On Error GoTo Err

SetNewTargetLimitPrice pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewTargetQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "IBracketOrder_SetNewTargetQuantity"
On Error GoTo Err

SetNewTargetQuantity pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IBracketOrder_SetNewTargetTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "IBracketOrder_SetNewTargetTriggerPrice"
On Error GoTo Err

SetNewTargetTriggerPrice pPriceSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IBracketOrder_Size() As BoxedDecimal
Set IBracketOrder_Size = Size
End Property

Private Property Get IBracketOrder_StartTime() As Date
IBracketOrder_StartTime = StartTime
End Property

Private Property Get IBracketOrder_State() As BracketOrderStates
IBracketOrder_State = State
End Property

Private Property Get IBracketOrder_StopLossOrder() As IOrder
Set IBracketOrder_StopLossOrder = mStopLossOrder
End Property

Private Property Let IBracketOrder_StopReason(ByVal RHS As String)
StopReason = RHS
End Property

Private Property Get IBracketOrder_StopReason() As String
IBracketOrder_StopReason = StopReason
End Property

Private Property Get IBracketOrder_TargetOrder() As IOrder
Set IBracketOrder_TargetOrder = mTargetOrder
End Property

Private Property Let IBracketOrder_TargetReason(ByVal RHS As String)
TargetReason = RHS
End Property

Private Property Get IBracketOrder_TargetReason() As String
IBracketOrder_TargetReason = TargetReason
End Property

Private Function IBracketOrder_ToString() As String
Const ProcName As String = "IBracketOrder_ToString"
On Error GoTo Err

IBracketOrder_ToString = ToString

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub IBracketOrder_Update()
Const ProcName As String = "IBracketOrder_Update"
On Error GoTo Err

Update

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' IChangeListener Interface Members
'@================================================================================

Private Sub IChangeListener_Change(ev As ChangeEventData)
Const ProcName As String = "IChangeListener_Change"
On Error GoTo Err

Dim lChangeType As OrderContextChangeTypes: lChangeType = ev.changeType
If lChangeType = OrderContextReadyStateChanged Then
    mOrderContext.RemoveChangeListener Me
    placePeggedOrders
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' IRecoverable Interface Members
'@================================================================================

Private Sub IRecoverable_AddRecoverableObjectListener(ByVal pListener As IRecoverableObjectListener)
Const ProcName As String = "IRecoverable_AddRecoverableObjectListener"
On Error GoTo Err

mRecoverableObjectListeners.Add pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IRecoverable_FinishProcessingOrderPersistenceData()

End Sub

Private Sub IRecoverable_FinishRecovery()
Const ProcName As String = "IRecoverable_FinishRecovery"
On Error GoTo Err

If mSummary.CancelPrice <> 0# Then
    Dim lPriceCanceller As New BracketPriceCanceller
    lPriceCanceller.Initialise Me, mSummary.CancelPrice, mDataSource
End If

If mSummary.CancelTime <> 0 And mSummary.CancelTime > GetTimestamp Then Set mCancelTLI = mTimerList.Add(Nothing, mSummary.CancelTime, ExpiryTimeUnits.ExpiryTimeUnitDateTime)

If mSummary.RolloverDate <> 0 And _
    (mSummary.State = BracketOrderStateSubmitted Or _
    mSummary.State = BracketOrderStateClosed) Then setRolloverTLI
    
If placePeggedOrders Then CheckComplete

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub IRecoverable_LoadRecoveryData( _
                ByVal pRecoveryContextName As String, _
                ByVal pData As Variant)
Const ProcName As String = "IRecoverable_LoadRecoveryData"
On Error GoTo Err

mRecoveryContextName = pRecoveryContextName

Dim lSummary As BOS: Set lSummary = pData
If mSummary.Key = "" Then
    mSummary.Key = lSummary.Key
    GIdProvider.gAddExistingId lSummary.Key
End If
lSummary.Diff.UpdateHost mSummary

setState mSummary.State
SetSize mSummary.Size

If Not mOrderContext Is Nothing Then
    If mSummary.CloseoutOrderId = "" Then
    ElseIf mCloseoutOrder Is Nothing Then
        SetCloseoutOrder CreateAnOrder(mSummary.CloseoutOrderId)
    ElseIf mCloseoutOrder.Id <> mSummary.CloseoutOrderId Then
        SetCloseoutOrder CreateAnOrder(mSummary.CloseoutOrderId)
    End If
    
    If mSummary.EntryOrderId = "" Then
    ElseIf mEntryOrder Is Nothing Then
        SetEntryOrder CreateAnOrder(mSummary.EntryOrderId)
    ElseIf mEntryOrder.Id <> mSummary.EntryOrderId Then
        SetEntryOrder CreateAnOrder(mSummary.EntryOrderId)
    End If
    
    If mSummary.StopLossOrderId = "" Then
    ElseIf mStopLossOrder Is Nothing Then
        SetStopLossOrder CreateAnOrder(mSummary.StopLossOrderId)
    ElseIf mStopLossOrder.Id <> mSummary.StopLossOrderId Then
        SetStopLossOrder CreateAnOrder(mSummary.StopLossOrderId)
    End If
    
    If mSummary.TargetOrderId = "" Then
    ElseIf mTargetOrder Is Nothing Then
        SetTargetOrder CreateAnOrder(mSummary.TargetOrderId)
    ElseIf mTargetOrder.Id <> mSummary.TargetOrderId Then
        SetTargetOrder CreateAnOrder(mSummary.TargetOrderId)
    End If
End If

mSummary.SetClean

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Property Get IRecoverable_ProgId() As String
IRecoverable_ProgId = ProjectName & "." & ModuleName
End Property

Private Property Get IRecoverable_RecoveryContextName() As String
IRecoverable_RecoveryContextName = mRecoveryContextName
End Property

Private Property Get IRecoverable_RecoveryData() As Variant
Set IRecoverable_RecoveryData = mSummary
End Property

Private Sub IRecoverable_RemoveRecoverableObjectListener(ByVal pListener As IRecoverableObjectListener)
Const ProcName As String = "IRecoverable_RemoveRecoverableObjectListener"
On Error GoTo Err

mRecoverableObjectListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' IStateChangeListener Interface Members
'@================================================================================

Private Sub IStateChangeListener_Change(ev As StateChangeEventData)
Const ProcName As String = "IStateChangeListener_Change"
On Error GoTo Err

Dim lState As RolloverControllerStates: lState = ev.State
Select Case lState
Case RolloverControllerStateClosingCurrentPosition
    WriteRecoveryDataComment "Rollover in progress"
    mIsRolloverInProgress = True
    fireChange BracketOrderChangeTypes.BracketOrderRolloverInitiated
Case RolloverControllerStateCreatingNextBracketOrder
    Set mNextContract = mRolloverController.NextContract
    fireChange BracketOrderRolloverGotContract
Case RolloverControllerStateCompleted
    WriteRecoveryDataComment "Rollover completed"
    mIsRolloverInProgress = False
    Set mNextBracketOrder = mRolloverController.NextBracketOrder
    
    mRolloverController.RemoveStateChangeListener Me
    Set mRolloverController = Nothing
    
    mSummary.RolloverDate = 0
    mSummary.RolloverSpecification = Nothing
    
    SaveRecoveryInfo
    
    fireChange BracketOrderChangeTypes.BracketOrderRolloverCompleted
    mOrderContext.NotifyBracketOrderClosed Me
Case RolloverControllerStateFailed
    WriteRecoveryDataComment "Rollover failed"
End Select

SaveRecoveryInfo

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' IStringable Interface Members
'@================================================================================

Private Function IStringable_ToString() As String
IStringable_ToString = ToString
End Function

'@================================================================================
' mCloseoutOrder Event Handlers
'@================================================================================

Private Sub mCloseoutOrder_Error(ByVal pErrorCode As Long, ByVal pErrorMsg As String)
Const ProcName As String = "mCloseoutOrder_Error"
On Error GoTo Err

mSummary.CloseoutSpecifier = Nothing
handleStimulus OpStimuli.StimCloseoutOrderCancelled
fireBracketOrderError mCloseoutOrder, pErrorCode, pErrorMsg

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mCloseoutOrder_Fill(ByVal pExec As IExecutionReport)
Const ProcName As String = "mCloseoutOrder_Fill"
On Error GoTo Err

gLogOrderMessage "Closeout order fill: " & _
                    gOrderActionToString(mCloseoutOrder.Action) & " " & pExec.Quantity & " at " & _
                    pExec.Price & "; remaining: " & mCloseoutOrder.QuantityRemaining, _
                mCloseoutOrder, mDataSource, mContract, Key, mIsSimulated, Me

processExecution pExec

fireChange BracketOrderCloseoutOrderFilled
RaiseEvent CloseoutOrderFilled

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mCloseoutOrder_Message(ByVal pMessage As String)
Const ProcName As String = "mCloseoutOrder_Message"
On Error GoTo Err

fireBracketOrderMessage mCloseoutOrder, pMessage

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mCloseoutOrder_PropertyChanged()
Const ProcName As String = "mCloseoutOrder_PropertyChanged"
On Error GoTo Err

fireChange BracketOrderCloseoutOrderChanged
RaiseEvent CloseoutOrderChanged

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mCloseoutOrder_StatusChanged()
Const ProcName As String = "mCloseoutOrder_StatusChanged"
On Error GoTo Err

Select Case mCloseoutOrder.Status
Case OrderStatuses.OrderStatusFilled
    gLogOrderMessage "Closeout order completed: " & _
                        gOrderActionToString(mCloseoutOrder.Action) & " " & mCloseoutOrder.QuantityFilled & " at " & _
                        mCloseoutOrder.AveragePrice, _
                    mCloseoutOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusPendingSubmit
Case OrderStatuses.OrderStatusCancelling
Case OrderStatuses.OrderStatusPreSubmitted
Case OrderStatuses.OrderStatusSubmitted
Case OrderStatuses.OrderStatusCancelled
    gLogOrderMessage "Closeout order cancelled", _
                    mCloseoutOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusRejected
    gLogOrderMessage "Closeout order rejected", _
                    mCloseoutOrder, mDataSource, mContract, Key, mIsSimulated, Me
End Select

fireChange BracketOrderCloseoutOrderChanged
RaiseEvent CloseoutOrderChanged


Select Case mCloseoutOrder.Status
Case OrderStatuses.OrderStatusFilled
    Assert Size = 0, Key & " Closeout incomplete: Size remaining is " & Size
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusRejected
    If Not mForceCloseTLI Is Nothing Then
        mForceCloseTLI.Cancel
        Set mForceCloseTLI = Nothing
    End If
    handleStimulus OpStimuli.StimCloseoutOrderRejected
Case OrderStatuses.OrderStatusCancelled
    If Not IsContractExpired(mContract, mClock) Then
        handleStimulus OpStimuli.StimCloseoutOrderCancelled
    End If
    checkAllOrdersComplete
End Select

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mEntryOrder Event Handlers
'@================================================================================

Private Sub mEntryOrder_Dirty()
Const ProcName As String = "mEntryOrder_Dirty"
On Error GoTo Err

setDirty

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mEntryOrder_Error(ByVal pErrorCode As Long, ByVal pErrorMsg As String)
Const ProcName As String = "mEntryOrder_Error"
On Error GoTo Err

If mSummary.State = BracketOrderStateClosingOut Then
    handleStimulus OpStimuli.StimEntryOrderCancelled
Else
    handleStimulus OpStimuli.StimOrderError
End If

fireBracketOrderError mEntryOrder, pErrorCode, pErrorMsg

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mEntryOrder_Fill(ByVal pExec As IExecutionReport)
Const ProcName As String = "mEntryOrder_Fill"
On Error GoTo Err

gLogOrderMessage "Entry order fill: " & _
                    gOrderActionToString(mEntryOrder.Action) & " " & pExec.Quantity & " at " & _
                    pExec.Price & "; remaining: " & mEntryOrder.QuantityRemaining, _
                mEntryOrder, mDataSource, mContract, Key, mIsSimulated, Me

processExecution pExec

placePeggedOrders
        
If Not mCancelTLI Is Nothing Then
    mCancelTLI.Cancel
    Set mCancelTLI = Nothing
End If

mSummary.CancelPrice = 0

'If Not mStopLossOrder Is Nothing Then
'    Dim Risk As Currency
'    If LongPosition Then
'        If mStopLossOrder.OrderType = OrderTypes.OrderTypeAutoStop Then
'            Risk = (mEntryOrder.Quantity + mEntryOrder.QuantityFilled) * mStopLossOrder.Offset * mContract.TickValue
'        Else
'            Risk = (mEntryOrder.Quantity + mEntryOrder.QuantityFilled) * (pExec.Price - mStopLossOrder.TriggerPrice) * mContract.Multiplier
'        End If
'    Else
'        If mStopLossOrder.OrderType = OrderTypes.OrderTypeAutoStop Then
'            Risk = -(mEntryOrder.Quantity + mEntryOrder.QuantityFilled) * mStopLossOrder.Offset * mContract.TickValue
'        Else
'            Risk = (mEntryOrder.Quantity + mEntryOrder.QuantityFilled) * (mStopLossOrder.TriggerPrice - pExec.Price) * mContract.Multiplier
'        End If
'    End If
'End If

If Not mStopLossOrder Is Nothing Then
    If mStopLossOrder.Quantity <> Abs(Size) And Abs(Size) <> 0 Then
        AdjustStopLoss mStopLossOrder.TriggerPriceSpec, CreateBoxedDecimal(Abs(Size))
    End If
End If

If Not mTargetOrder Is Nothing Then
    If mTargetOrder.Quantity <> Abs(Size) And Abs(Size) <> 0 Then
        AdjustTarget mTargetOrder.LimitPriceSpec, CreateBoxedDecimal(Abs(Size))
    End If
End If

handleStimulus OpStimuli.StimEntryOrderFill

If State <> BracketOrderStateCancelling Then
    fireChange BracketOrderEntryOrderFilled
    RaiseEvent EntryOrderFilled
End If

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mEntryOrder_Message(ByVal pMessage As String)
Const ProcName As String = "mEntryOrder_Message"
On Error GoTo Err

fireBracketOrderMessage mEntryOrder, pMessage

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mEntryOrder_PropertyChanged()
Const ProcName As String = "mEntryOrder_PropertyChanged"
On Error GoTo Err

fireChange BracketOrderEntryOrderChanged
RaiseEvent EntryOrderChanged

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mEntryOrder_StatusChanged()
Const ProcName As String = "mEntryOrder_StatusChanged"
On Error GoTo Err

Select Case mEntryOrder.Status
Case OrderStatuses.OrderStatusFilled
    gLogOrderMessage "Entry order completed: " & _
                        gOrderActionToString(mEntryOrder.Action) & " " & mEntryOrder.QuantityFilled & " at " & _
                        mEntryOrder.AveragePrice, _
                    mEntryOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusCancelled
    gLogOrderMessage "Entry order cancelled", _
                    mEntryOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusRejected
    gLogOrderMessage "Entry order rejected", _
                    mEntryOrder, mDataSource, mContract, Key, mIsSimulated, Me
End Select

fireChange BracketOrderEntryOrderChanged
RaiseEvent EntryOrderChanged

Select Case mEntryOrder.Status
Case OrderStatuses.OrderStatusFilled
    mSummary.CancelPrice = 0
    RaiseEvent EntryOrderFilled
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusPendingSubmit
Case OrderStatuses.OrderStatusCancelling
Case OrderStatuses.OrderStatusPreSubmitted
Case OrderStatuses.OrderStatusSubmitted
Case OrderStatuses.OrderStatusCancelled
    If Not IsContractExpired(mContract, mClock) Then
        handleStimulus OpStimuli.StimEntryOrderCancelled
    End If
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusRejected
    Cancel
    checkAllOrdersComplete
End Select

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mDelayedCloseoutTLI Event Handlers
'@================================================================================

Private Sub mDelayedCloseoutTLI_StateChange(ev As TWUtilities40.StateChangeEventData)
Const ProcName As String = "mDelayedCloseoutTLI_StateChange"
On Error GoTo Err

Dim lState As TimerListItemStates: lState = ev.State
If lState <> TimerListItemStateExpired Then Exit Sub

placeCloseoutOrder

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' mForceCloseTLI Event Handlers
'@================================================================================

Private Sub mForceCloseTLI_StateChange(ev As StateChangeEventData)
Const ProcName As String = "mForceCloseTLI_StateChange"
On Error GoTo Err

Dim lState As TimerListItemStates: lState = ev.State
If lState <> TimerListItemStateExpired Then Exit Sub

DoCloseOut

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mRolloverTLI Event Handlers
'@================================================================================

Private Sub mRolloverTLI_StateChange(ev As StateChangeEventData)
Const ProcName As String = "mRolloverTLI_StateChange"
On Error GoTo Err

Dim lState As TimerListItemStates: lState = ev.State
If lState <> TimerListItemStateExpired Then Exit Sub

setRolloverTLI

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mStateTimeoutTLI Event Handlers
'@================================================================================

Private Sub mStateTimeoutTLI_StateChange(ev As StateChangeEventData)
Const ProcName As String = "mStateTimeoutTLI_TimerExpired"
On Error GoTo Err

If ev.State <> TimerListItemStates.TimerListItemStateExpired Then Exit Sub

handleStimulus OpStimuli.StimTimeoutExpired

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mStopLossOrder Event Handlers
'@================================================================================

Private Sub mStopLossOrder_Dirty()
Const ProcName As String = "mStopLossOrder_Dirty"
On Error GoTo Err

setDirty

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mStopLossOrder_Error(ByVal pErrorCode As Long, ByVal pErrorMsg As String)
Const ProcName As String = "mStopLossOrder_Error"
On Error GoTo Err

handleStimulus OpStimuli.StimOrderError
fireBracketOrderError mStopLossOrder, pErrorCode, pErrorMsg

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mStopLossOrder_Fill(ByVal pExec As IExecutionReport)
Const ProcName As String = "mStopLossOrder_Fill"
On Error GoTo Err

gLogOrderMessage "Stop-loss order fill: " & _
                    gOrderActionToString(mStopLossOrder.Action) & " " & pExec.Quantity & " at " & _
                    pExec.Price & "; remaining: " & mStopLossOrder.QuantityRemaining, _
                mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me

processExecution pExec

If Not mTargetOrder Is Nothing Then
    If mTargetOrder.Quantity <> Abs(Size) And Abs(Size) <> 0 Then
        AdjustTarget mTargetOrder.LimitPriceSpec, CreateBoxedDecimal(Abs(Size))
    End If
End If

fireChange BracketOrderStopLossOrderFilled
RaiseEvent StopLossOrderFilled

SaveRecoveryInfo

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mStopLossOrder_Message(ByVal pMessage As String)
Const ProcName As String = "mStopLossOrder_Message"
On Error GoTo Err

fireBracketOrderMessage mStopLossOrder, pMessage

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mStopLossOrder_PropertyChanged()
Const ProcName As String = "mStopLossOrder_PropertyChanged"
On Error GoTo Err

fireChange BracketOrderStopLossOrderChanged
RaiseEvent StopLossOrderChanged

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mStopLossOrder_StatusChanged()
Const ProcName As String = "mStopLossOrder_StatusChanged"
On Error GoTo Err

Select Case mStopLossOrder.Status
Case OrderStatuses.OrderStatusFilled
    gLogOrderMessage "Stop-loss order completed: " & _
                        gOrderActionToString(mStopLossOrder.Action) & " " & mStopLossOrder.QuantityFilled & " at " & _
                        mStopLossOrder.AveragePrice, _
                    mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusCancelled
    gLogOrderMessage "Stop-loss order cancelled", _
                    mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusRejected
    gLogOrderMessage "Stop-loss order rejected", _
                    mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
End Select

fireChange BracketOrderStopLossOrderChanged
RaiseEvent StopLossOrderChanged

Select Case mStopLossOrder.Status
Case OrderStatuses.OrderStatusFilled
    RaiseEvent StopLossOrderFilled
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusPendingSubmit
Case OrderStatuses.OrderStatusCancelling
Case OrderStatuses.OrderStatusPreSubmitted
Case OrderStatuses.OrderStatusSubmitted
Case OrderStatuses.OrderStatusCancelled
    If Not IsContractExpired(mContract, mClock) Then
        handleStimulus OpStimuli.StimStopLossOrderCancelled
    End If
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusRejected
    handleStimulus OpStimuli.StimStopLossOrderCancelled
    checkAllOrdersComplete
End Select

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mTargetOrder Event Handlers
'@================================================================================

Private Sub mTargetOrder_Dirty()
Const ProcName As String = "mTargetOrder_Dirty"
On Error GoTo Err

setDirty

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mTargetOrder_Error(ByVal pErrorCode As Long, ByVal pErrorMsg As String)
Const ProcName As String = "mTargetOrder_Error"
On Error GoTo Err

handleStimulus OpStimuli.StimOrderError
fireBracketOrderError mTargetOrder, pErrorCode, pErrorMsg

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mTargetOrder_Fill(ByVal pExec As IExecutionReport)
Const ProcName As String = "mTargetOrder_Fill"
On Error GoTo Err

gLogOrderMessage "Target order fill: " & _
                    gOrderActionToString(mTargetOrder.Action) & " " & pExec.Quantity & " at " & _
                    pExec.Price & "; remaining: " & mTargetOrder.QuantityRemaining, _
                mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me

processExecution pExec

If Not mStopLossOrder Is Nothing Then
    If mStopLossOrder.Quantity <> Abs(Size) And Abs(Size) <> 0 Then
        AdjustStopLoss mStopLossOrder.TriggerPriceSpec, CreateBoxedDecimal(Abs(Size))
    End If
End If

fireChange BracketOrderTargetOrderFilled
RaiseEvent TargetOrderFilled

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mTargetOrder_Message(ByVal pMessage As String)
Const ProcName As String = "mTargetOrder_Message"
On Error GoTo Err

fireBracketOrderMessage mTargetOrder, pMessage

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mTargetOrder_PropertyChanged()
Const ProcName As String = "mTargetOrder_PropertyChanged"
On Error GoTo Err

fireChange BracketOrderTargetOrderChanged
RaiseEvent TargetOrderChanged

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

Private Sub mTargetOrder_StatusChanged()
Const ProcName As String = "mTargetOrder_StatusChanged"
On Error GoTo Err

Select Case mTargetOrder.Status
Case OrderStatuses.OrderStatusFilled
    gLogOrderMessage "Target order completed: " & _
                        gOrderActionToString(mTargetOrder.Action) & " " & mTargetOrder.QuantityFilled & " at " & _
                        mTargetOrder.AveragePrice, _
                    mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusCancelled
    gLogOrderMessage "Target order cancelled", _
                    mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
Case OrderStatuses.OrderStatusRejected
    gLogOrderMessage "Target order rejected", _
                    mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
End Select

fireChange BracketOrderTargetOrderChanged
RaiseEvent TargetOrderChanged

Select Case mTargetOrder.Status
Case OrderStatuses.OrderStatusFilled
    RaiseEvent TargetOrderFilled
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusCancelling
Case OrderStatuses.OrderStatusPendingSubmit
Case OrderStatuses.OrderStatusSubmitted
Case OrderStatuses.OrderStatusCancelled
    If Not IsContractExpired(mContract, mClock) Then
        handleStimulus OpStimuli.StimTargetOrderCancelled
    End If
    checkAllOrdersComplete
Case OrderStatuses.OrderStatusRejected
    handleStimulus OpStimuli.StimTargetOrderCancelled
    checkAllOrdersComplete
End Select

SaveRecoveryInfo
Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' mCancelTLI Event Handlers
'@================================================================================

Private Sub mCancelTLI_StateChange(ev As StateChangeEventData)
Const ProcName As String = "mCancelTLI_StateChange"
On Error GoTo Err

If ev.State <> TimerListItemStates.TimerListItemStateExpired Then Exit Sub

SelfCancel "Cancel time expired"

Exit Sub

Err:
gNotifyUnhandledError ProcName, ModuleName
End Sub

'@================================================================================
' Properties
'@================================================================================

Public Property Get ApplicationIndex() As Long
ApplicationIndex = mApplicationIndex
End Property

Public Property Let AutosizeType(ByVal Value As BracketAutosizeTypes)
Const ProcName As String = "AutosizeType"
On Error GoTo Err

Select Case Value
Case BracketAutosizeNone
Case BracketAutosizePercentOfAccount
Case BracketAutosizeMonetaryAmount
Case Else
    AssertArgument False, "Invalid AutosizeType"
End Select

mSummary.AutosizeType = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get AutosizeType() As BracketAutosizeTypes
AutosizeType = mSummary.AutosizeType
End Property

Public Property Let AutosizeValue(ByVal Value As Double)
Const ProcName As String = "AutosizeValue"
On Error GoTo Err

Assert mSummary.State = BracketOrderStateCreated, "AutosizeValue can only be set in Created state"
AssertArgument Value > 0#, "AutosizeValue: must be greater than 0.0"

mSummary.AutosizeValue = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get AutosizeValue() As Double
AutosizeValue = mSummary.AutosizeValue
End Property

Public Property Let CancelAfter(ByVal Value As Long)
Const ProcName As String = "CancelAfter"
On Error GoTo Err

If State = BracketOrderStateClosed Then Exit Property

Assert State = BracketOrderStateCreated, Key & " CancelAfter cannot be set after execution"
Assert mSummary.CancelTime = 0, "CancelTime is already set"

mCancelAfter = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Let CancelPrice(ByVal Value As Double)
Const ProcName As String = "CancelPrice"
On Error GoTo Err

If State = BracketOrderStateClosed Then Exit Property

Assert State = BracketOrderStateCreated, Key & " CancelPrice cannot be set after execution"

mSummary.CancelPrice = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get CancelPrice() As Double
CancelPrice = mSummary.CancelPrice
End Property

Public Property Let CancelTime(ByVal Value As Date)
Const ProcName As String = "CancelTime"
On Error GoTo Err

If State = BracketOrderStateClosed Then Exit Property

Assert State = BracketOrderStateCreated, Key & " CancelTime cannot be set after execution"
Assert mCancelAfter = 0, "CancelAfter is already set"

mSummary.CancelTime = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get CancelTime() As Date
CancelTime = mSummary.CancelTime
End Property

Public Property Get CloseoutOrder() As IOrder
Set CloseoutOrder = mCloseoutOrder
End Property

Public Property Get Contract() As IContract
Const ProcName As String = "Contract"
On Error GoTo Err

Set Contract = mContract

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Friend Property Let CreationTime(ByVal Value As Date)
Const ProcName As String = "CreationTime"
On Error GoTo Err

mSummary.CreationTime = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get CreationTime() As Date
CreationTime = mSummary.CreationTime
End Property

Friend Property Let CumBuyPrice(ByVal Value As BoxedDecimal)
mSummary.CumBuyPrice = Value
End Property

Public Property Get CumBuyPrice() As BoxedDecimal
Set CumBuyPrice = mSummary.CumBuyPrice
End Property

Friend Property Let CumSellPrice(ByVal Value As BoxedDecimal)
Const ProcName As String = "CumSellPrice"
On Error GoTo Err

mSummary.CumSellPrice = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get CumSellPrice() As BoxedDecimal
Set CumSellPrice = mSummary.CumSellPrice
End Property

Public Property Let Description(ByVal Value As String)
Const ProcName As String = "Description"
On Error GoTo Err

mSummary.Description = Value
If State <> BracketOrderStateCreated Then SaveRecoveryInfo

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get Description() As String
Description = mSummary.Description
End Property

Public Property Get EntryOrder() As IOrder
Set EntryOrder = mEntryOrder
End Property

Public Property Get EntryPrice() As Double
Const ProcName As String = "EntryPrice"
On Error GoTo Err

If LongPosition Then
    EntryPrice = mSummary.CumBuyPrice.Div(mEntryOrder.Quantity)
Else
    EntryPrice = mSummary.CumSellPrice.Div(mEntryOrder.Quantity)
End If

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Let EntryReason(ByVal Value As String)
Const ProcName As String = "EntryReason"
On Error GoTo Err

mSummary.EntryReason = Value
If State <> BracketOrderStateCreated Then SaveRecoveryInfo

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get EntryReason() As String
EntryReason = mSummary.EntryReason
End Property

Public Property Get ExitPrice() As Double
Const ProcName As String = "ExitPrice"
On Error GoTo Err

If LongPosition Then
    ExitPrice = mSummary.CumSellPrice / mEntryOrder.Quantity
Else
    ExitPrice = mSummary.CumBuyPrice / mEntryOrder.Quantity
End If

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get GroupName() As String
GroupName = mSummary.GroupName
End Property

Public Property Get HasRolloverSpecification() As Boolean
HasRolloverSpecification = (Not mSummary.RolloverSpecification Is Nothing)
End Property

Public Property Get IsComplete() As Boolean
Const ProcName As String = "IsComplete"
On Error GoTo Err

IsComplete = (mStateEngine.State = BracketOrderStates.BracketOrderStateClosed)

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get IsDirty() As Boolean
IsDirty = mIsDirty
End Property

Public Property Get IsRiskUnlimited() As Boolean
Const ProcName As String = "IsRiskUnlimited"
On Error GoTo Err

IsRiskUnlimited = (Risk = MaxCurrency)

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get IsRolloverInProgress() As Boolean
IsRolloverInProgress = mIsRolloverInProgress
End Property

Public Property Get IsSimulated() As Boolean
IsSimulated = mIsSimulated
End Property

Public Property Get Key() As String
Key = mSummary.Key
End Property

Public Property Get LongPosition() As Boolean
Const ProcName As String = "LongPosition"
On Error GoTo Err

If Not mEntryOrder Is Nothing Then LongPosition = (mEntryOrder.Action = OrderActionBuy)

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Let LotSize(ByVal Value As Long)
Const ProcName As String = "LotSize"
On Error GoTo Err

Assert mSummary.State = BracketOrderStateCreated, "LotSize can only be set in Created state"
AssertArgument IsInteger(Value, 1, 1000), "Invalid lot size: must be an integer between 1 and 1000"

mSummary.LotSize = Value

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get LotSize() As Long
LotSize = mSummary.LotSize
End Property

Public Property Get NextBracketOrder() As IBracketOrder
Set NextBracketOrder = mNextBracketOrder
End Property

Public Property Get NextContract() As IContract
Set NextContract = mNextContract
End Property

Public Property Get Order(ByVal pRole As BracketOrderRoles) As IOrder
Const ProcName As String = "Order"
On Error GoTo Err

Select Case pRole
Case BracketOrderRoleEntry
    Set Order = mEntryOrder
Case BracketOrderRoleStopLoss
    Set Order = mStopLossOrder
Case BracketOrderRoleTarget
    Set Order = mTargetOrder
Case BracketOrderRoleCloseout
    Set Order = mCloseoutOrder
Case Else
    AssertArgument False, Key & " Invalid pRole"
End Select

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get OrderContext() As OrderContext
Const ProcName As String = "OrderContext"
On Error GoTo Err

Set OrderContext = mOrderContext

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get NumberOfOrders() As Long
Const ProcName As String = "NumberOfOrders"
On Error GoTo Err

NumberOfOrders = mNumberOfOrders

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get PendingSize() As BoxedDecimal
Const ProcName As String = "PendingSize"
On Error GoTo Err

If mEntryOrder Is Nothing Then Set PendingSize = DecimalZero: Exit Property
If mStateEngine.State = BracketOrderStates.BracketOrderStateClosed Then Set PendingSize = DecimalZero: Exit Property
If LongPosition Then
    Set PendingSize = mEntryOrder.QuantityRemaining
Else
    Set PendingSize = CreateBoxedDecimal(-mEntryOrder.QuantityRemaining)
End If

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Let PreventUnprotectedPosition( _
                ByVal Value As Boolean)
Const ProcName As String = "PreventUnprotectedPosition"
On Error GoTo Err

Assert (Not Value) Or (State = BracketOrderStateCreated) Or (Not mStopLossOrder Is Nothing), Key & " No stop-loss order exists"

mSummary.PreventUnprotectedPosition = Value
If State <> BracketOrderStateCreated Then SaveRecoveryInfo

If mSummary.PreventUnprotectedPosition Then
    mStateEngine.SetConditions OpConditions.CondProtected
Else
    mStateEngine.ClearConditions OpConditions.CondProtected
End If

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get PreventUnprotectedPosition() As Boolean
Const ProcName As String = "PreventUnprotectedPosition"
On Error GoTo Err

PreventUnprotectedPosition = mSummary.PreventUnprotectedPosition

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get Risk() As Currency
Const ProcName As String = "Risk"
On Error GoTo Err

If mStopLossOrder Is Nothing Then
    Risk = MaxCurrency
    Exit Property
End If

If mStateEngine.State = BracketOrderStates.BracketOrderStateClosed Then Exit Property

If mStopLossOrder.Status = OrderStatuses.OrderStatusFilled Then Exit Property

' the amount at Risk has two parts - that due to fills already obtained, and
' that due to fills pending.

Dim filledTotalPrice As Double
filledTotalPrice = mEntryOrder.QuantityFilled * mEntryOrder.AveragePrice

Dim pendingTotalPrice As Double
Select Case EntryOrder.OrderType
    Case OrderTypes.OrderTypeMarket
        pendingTotalPrice = mEntryOrder.QuantityRemaining * _
                IIf(LongPosition, mDataSource.CurrentTick(TickTypeAsk).Price, mDataSource.CurrentTick(TickTypeBid).Price)
    Case OrderTypes.OrderTypeLimit, _
            OrderTypes.OrderTypeStopLimit, _
            OrderTypeLimitIfTouched, _
            OrderTypeMarketIfTouched
        pendingTotalPrice = mEntryOrder.QuantityRemaining * mEntryOrder.LimitPrice
    Case OrderTypes.OrderTypeStop
        pendingTotalPrice = mEntryOrder.QuantityRemaining * mEntryOrder.TriggerPrice
    
    
' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
' need to work out what to do with the rest of these
' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Case OrderTypeMarketOnClose
    Case OrderTypeLimitOnClose
    Case OrderTypePeggedToMarket
    Case OrderTypeRelative
    Case OrderTypeMarketToLimit
    Case OrderTypeTrailLimit
    Case OrderTypeMarketWithProtection
    Case OrderTypeMarketOnOpen
    Case OrderTypeLimitOnOpen
    Case OrderTypePeggedToPrimary
End Select

Dim stopTotalPrice As Double
stopTotalPrice = mStopLossOrder.TriggerPrice * _
                        (mEntryOrder.Quantity + mEntryOrder.QuantityFilled)
If LongPosition Then
    Risk = mContract.TickValue * (filledTotalPrice + pendingTotalPrice - stopTotalPrice) / mContract.TickSize
Else
    Risk = mContract.TickValue * (stopTotalPrice - filledTotalPrice - pendingTotalPrice) / mContract.TickSize
End If

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get RolloverDate() As Date
RolloverDate = mSummary.RolloverDate
End Property

Public Property Get RolloverSpecification() As RolloverSpecification
Set RolloverSpecification = mSummary.RolloverSpecification
End Property

Public Property Let RolloverSpecification(ByVal Value As RolloverSpecification)
Const ProcName As String = "RolloverSpecification"
On Error GoTo Err

If mSummary.RolloverSpecification Is Nothing And Value Is Nothing Then Exit Property

Assert Value Is Nothing Or _
        mSummary.State = BracketOrderStateCreated Or _
        mSummary.State = BracketOrderStateSubmitted, _
        "Bracket order state does not allow rollover"

mSummary.RolloverSpecification = Value
mSummary.RolloverDate = 0

If Not mRolloverTLI Is Nothing Then
    mRolloverTLI.Cancel
    Set mRolloverTLI = Nothing
End If

If Not mSummary.RolloverSpecification Is Nothing Then
    Dim lRolloverTime As Date
    lRolloverTime = GetOffsetSessionTimes( _
                        mContract.ExpiryDate, _
                        -1 * mSummary.RolloverSpecification.Days).StartTime + _
                            mSummary.RolloverSpecification.Time
    
    Dim lTz As TimeZone: Set lTz = GetTimeZone(mContract.TimezoneName)
    mSummary.RolloverDate = ConvertDateTzToLocal(lRolloverTime, lTz)
End If

SaveRecoveryInfo

If mSummary.RolloverSpecification Is Nothing Then Exit Property

If mSummary.State = BracketOrderStateSubmitted Then setRolloverTLI

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get Size() As BoxedDecimal
Set Size = mSummary.Size
End Property

Public Property Get StartTime() As Date
StartTime = mSummary.StartTime
End Property

Public Property Get EndTime() As Date
EndTime = mSummary.EndTime
End Property

Private Sub setPrice( _
                ByVal pOrder As IOrder, _
                ByVal pPermittedOrderTypes As OrderTypes, _
                ByRef pPriceSpec As PriceSpecifier, _
                ByVal pNewPriceSpec As PriceSpecifier, _
                ByVal pChangedFieldName As String)
Const ProcName As String = "setPrice"
On Error GoTo Err

AssertArgument Not pOrder Is Nothing, Key & " Order is Nothing"
AssertArgument pNewPriceSpec.IsValid, Key & " New price specifier is invalid"

Select Case mStateEngine.State
Case BracketOrderStates.BracketOrderStateCancelling
    Exit Sub
Case BracketOrderStates.BracketOrderStateCreated
Case BracketOrderStates.BracketOrderStateSubmitted
Case Else
    Assert False, Key & " Action not allowed in state " & mStateEngine.State
End Select

Assert pOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change " & pChangedFieldName & " - order " & pOrder.Id & " already filled"

Assert ((pOrder.OrderType And pPermittedOrderTypes) = CLng(pOrder.OrderType)), _
         Key & " Can't change " & pChangedFieldName & " for order type " & gOrderTypeToString(pOrder.OrderType)

If Not pNewPriceSpec.Equals(pPriceSpec) Then
    gLogBracketOrderMessage "Set " & pChangedFieldName & "=" & gPriceSpecifierToString(pNewPriceSpec, mContract), _
                    mDataSource, mContract, Key, mIsSimulated, Me
    Set pPriceSpec = pNewPriceSpec
    setDirty
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub setQuantity( _
                ByVal pOrder As IOrder, _
                ByRef pField As BoxedDecimal, _
                ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "setQuantity"
On Error GoTo Err

Assert Not pOrder Is Nothing, Key & " Order is Nothing"

Select Case mStateEngine.State
Case BracketOrderStates.BracketOrderStateCancelling
    Exit Sub
Case BracketOrderStates.BracketOrderStateCreated
Case BracketOrderStates.BracketOrderStateSubmitted
Case Else
    Assert False, Key & " Action not allowed in state " & mStateEngine.State
End Select

Assert pOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change quantity - order " & pOrder.Id & " already filled"

If Not pNewQuantity.EQ(pOrder.Quantity) Then
    gLogBracketOrderMessage "Set quantity=" & DecimalToString(pNewQuantity), _
                    mDataSource, mContract, Key, mIsSimulated, Me
    Set pField = pNewQuantity
    setDirty
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub setRolloverTLI()
Const ProcName As String = "setRolloverTLI"
On Error GoTo Err

If mSummary.CumBuyPrice = 0 And mSummary.CumSellPrice = 0 Then
    ' we haven't had any fills yet, so we need to defer the rollover
    ' until we have
    Exit Sub
End If

If mSummary.RolloverDate <= GetTimestamp Then
    Dim lExpiryTime As Date
    lExpiryTime = mContract.ExpiryDate + mContract.SessionEndTime
    Dim lTz As TimeZone: Set lTz = GetTimeZone(mContract.TimezoneName)
    lExpiryTime = ConvertDateTzToLocal(lExpiryTime, lTz)
    If lExpiryTime > GetTimestamp Then
        initiateRollover
    End If
ElseIf Int(mSummary.RolloverDate - GetTimestamp) > 20 Then
    ' too long for a timer list entry! Max is about 24 days
    Set mRolloverTLI = mTimerList.Add(Nothing, GetTimestamp + 20, ExpiryTimeUnitDateTime)
Else
    Set mRolloverTLI = mTimerList.Add(Nothing, mSummary.RolloverDate, ExpiryTimeUnitDateTime)
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub setState(ByVal Value As BracketOrderStates)
Const ProcName As String = "setState"
On Error GoTo Err

Dim lConditions As OpConditions
If Not mStateEngine Is Nothing Then lConditions = mStateEngine.Conditions

Set mStateEngine = CreateStateEngine(GBracketOrder.TableBuilder, _
                                    Value)
mStateEngine.SetConditions lConditions

mSummary.State = Value
If IsComplete Then doCompletionActions

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Property Get State() As BracketOrderStates
Const ProcName As String = "State"
On Error GoTo Err

State = mStateEngine.State

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get StopLossOrder() As IOrder
Set StopLossOrder = mStopLossOrder
End Property

Public Property Let StopReason(ByVal Value As String)
Const ProcName As String = "StopReason"
On Error GoTo Err

mSummary.StopReason = Value
If State <> BracketOrderStateCreated Then SaveRecoveryInfo

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get StopReason() As String
StopReason = mSummary.StopReason
End Property

Public Property Get TargetOrder() As IOrder
Set TargetOrder = mTargetOrder
End Property

Public Property Let TargetReason(ByVal Value As String)
Const ProcName As String = "TargetReason"
On Error GoTo Err

mSummary.TargetReason = Value
If State <> BracketOrderStateCreated Then SaveRecoveryInfo

Exit Property

Err:
gHandleUnexpectedError ProcName, ModuleName
End Property

Public Property Get TargetReason() As String
TargetReason = mSummary.TargetReason
End Property

Public Property Get DataSource() As IMarketDataSource
Set DataSource = mDataSource
End Property

'@================================================================================
' Methods
'@================================================================================

Friend Sub Activate()
Const ProcName As String = "Activate"
On Error GoTo Err

fireChange BracketOrderCreated
If Not mEntryOrder Is Nothing Then
    fireChange BracketOrderEntryOrderChanged
    RaiseEvent EntryOrderChanged
End If
If Not mStopLossOrder Is Nothing Then
    fireChange BracketOrderStopLossOrderChanged
    RaiseEvent StopLossOrderChanged
End If
If Not mTargetOrder Is Nothing Then
    fireChange BracketOrderTargetOrderChanged
    RaiseEvent TargetOrderChanged
End If
If Not mCloseoutOrder Is Nothing Then
    fireChange BracketOrderCloseoutOrderChanged
    RaiseEvent CloseoutOrderChanged
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddBracketOrderErrorListener(ByVal pListener As IBracketOrderErrorListener)
Const ProcName As String = "AddBracketOrderErrorListener"
On Error GoTo Err

mBracketOrderErrorListeners.Add pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddBracketOrderMessageListener(ByVal pListener As IBracketOrderMsgListener)
Const ProcName As String = "AddBracketOrderMessageListener"
On Error GoTo Err

mBracketOrderMessageListeners.Add pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "AddChangeListener"
On Error GoTo Err

mChangeListeners.Add pListener

' notify this new listenener that we are already created
Dim ev As ChangeEventData
Set ev.Source = Me
ev.changeType = BracketOrderChangeTypes.BracketOrderCreated
pListener.Change ev

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddExecutionListener(ByVal pListener As IExecutionListener)
Const ProcName As String = "AddExecutionListener"
On Error GoTo Err

mExecutionListeners.Add pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AddStateChangeListener(ByVal pListener As IStateChangeListener)
Const ProcName As String = "AddStateChangeListener"
On Error GoTo Err

mStateChangeListeners.Add pListener

Exit Sub

Err:
If Err.Number = VBErrorCodes.VbErrElementAlreadyExists Then Exit Sub
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AdjustStopLoss(ByVal stopTriggerPriceSpec As PriceSpecifier, _
                    Optional ByVal Quantity As BoxedDecimal)
Const ProcName As String = "AdjustStopLoss"
On Error GoTo Err

SetNewStopLossTriggerPrice stopTriggerPriceSpec
If Not Quantity Is Nothing Then SetNewStopLossQuantity Quantity
WriteRecoveryDataComment ProcName & "()"
Update

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub AdjustTarget(ByVal targetPriceSpec As PriceSpecifier, _
                    Optional ByVal Quantity As BoxedDecimal)
Const ProcName As String = "AdjustTarget"
On Error GoTo Err

SetNewTargetLimitPrice targetPriceSpec
If Not Quantity Is Nothing Then SetNewTargetQuantity Quantity
WriteRecoveryDataComment ProcName & "()"
Update

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Function Cancel(Optional ByVal evenIfFilled As Boolean = False) As Boolean
Const ProcName As String = "Cancel"
On Error GoTo Err

mSummary.CancelPrice = 0
If Not mCancelTLI Is Nothing Then
    If mCancelTLI.State = TimerListItemStatePending Then mCancelTLI.Cancel
    Set mCancelTLI = Nothing
End If

RolloverSpecification = Nothing
If mIsRolloverInProgress Then
    mRolloverController.Cancel
    Set mRolloverController = Nothing
End If

WriteRecoveryDataComment ProcName & "(" & evenIfFilled & ")"
If evenIfFilled Then
    mStateEngine.ClearConditions OpConditions.CondNoFillCancellation
    Cancel = handleStimulus(OpStimuli.StimCancelEvenIfFill)
Else
    mStateEngine.SetConditions OpConditions.CondNoFillCancellation
    Cancel = handleStimulus(OpStimuli.StimCancelIfNoFill)
End If

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

''
' Cancels any changes made to this <code>BracketOrder</code> that have not yet
' been actioned.
'@/
Public Sub CancelChanges()
Const ProcName As String = "CancelChanges"
On Error GoTo Err

Set mNewEntryQuantity = Nothing
Set mNewStopLossQuantity = Nothing
Set mNewTargetQuantity = Nothing

Set mNewEntryLimitPriceSpec = gNewPriceSpecifier
Set mNewEntryTriggerPriceSpec = gNewPriceSpecifier

Set mNewStopLossLimitPriceSpec = gNewPriceSpecifier
Set mNewStopLossTriggerPriceSpec = gNewPriceSpecifier

Set mNewTargetLimitPriceSpec = gNewPriceSpecifier
Set mNewTargetTriggerPriceSpec = gNewPriceSpecifier

''
' note that we can't just use the copies because external
' code may have references to the member orders which must
' remain valid
'@/
gSyncToOrder mEntryOrder, mEntryOrderCopy
mEntryOrder.SetClean
gSyncToOrder mStopLossOrder, mStopOrderCopy
mStopLossOrder.SetClean
gSyncToOrder mTargetOrder, mTargetOrderCopy
mTargetOrder.SetClean

mIsDirty = False
fireChange BracketOrderChangeTypes.BracketOrderChangesCancelled
RaiseEvent ChangesCancelled

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub CheckComplete()
Const ProcName As String = "CheckComplete"
On Error GoTo Err

checkAllOrdersComplete

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

''
' Copies the current state of the member orders for use by cancelChanges
'@/
Public Sub Checkpoint()
Const ProcName As String = "Checkpoint"
On Error GoTo Err

Set mEntryOrderCopy = mEntryOrder.Clone
mEntryOrder.SetClean

If Not mStopLossOrder Is Nothing Then
    Set mStopOrderCopy = mStopLossOrder.Clone
    mStopLossOrder.SetClean
End If

If Not mTargetOrder Is Nothing Then
    Set mTargetOrderCopy = mTargetOrder.Clone
    mTargetOrder.SetClean
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub CloseOut( _
                Optional ByVal pCloseoutSpec As CloseoutSpecifier)
Const ProcName As String = "CloseOut"
On Error GoTo Err

RolloverSpecification = Nothing
If mIsRolloverInProgress Then
    mRolloverController.Cancel
    Set mRolloverController = Nothing
End If

WriteRecoveryDataComment ProcName & "()"
DoCloseOut pCloseoutSpec

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Function ContainsOrder( _
                ByVal pOrder As IOrder) As Boolean
Const ProcName As String = "ContainsOrder"
On Error GoTo Err

AssertArgument Not pOrder Is Nothing, Key & " pOrder is Nothing"

ContainsOrder = True
If mEntryOrder Is pOrder Then Exit Function
If mStopLossOrder Is pOrder Then Exit Function
If mTargetOrder Is pOrder Then Exit Function
If mCloseoutOrder Is pOrder Then Exit Function
ContainsOrder = False

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Friend Sub DoCloseOut( _
                Optional ByVal pCloseoutSpec As CloseoutSpecifier)
Const ProcName As String = "DoCloseOut"
On Error GoTo Err

mSummary.CloseoutSpecifier = pCloseoutSpec

gLogBracketOrderMessage "Closing out: " & _
                    "size=" & Size & _
                    "; pending size=" & PendingSize, _
                mDataSource, mContract, Key, mIsSimulated, Me

WriteRecoveryDataComment ProcName & "()"
handleStimulus OpStimuli.StimCloseout

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub Execute()
Const ProcName As String = "Execute"
On Error GoTo Err

Assert (Not mSummary.PreventUnprotectedPosition) Or (Not mStopLossOrder Is Nothing), Key & " No stop-loss order exists"

Dim lTimestamp As Date: lTimestamp = mTimerList.Clock.Timestamp
mSummary.CreationTime = lTimestamp

If mCancelAfter <> 0 Then
    mSummary.CancelTime = lTimestamp + CDbl(mCancelAfter) / 86400#
    mCancelAfter = 0
End If

If mSummary.CancelTime <> 0 Then Set mCancelTLI = mTimerList.Add(Nothing, mSummary.CancelTime, ExpiryTimeUnits.ExpiryTimeUnitDateTime)
    
If mSummary.CancelPrice <> 0# Then
    Dim lPriceCanceller As New BracketPriceCanceller
    lPriceCanceller.Initialise Me, mSummary.CancelPrice, mDataSource
End If

fireChange BracketOrderChangeTypes.BracketOrderCreated
WriteRecoveryDataComment ProcName & "()"

SaveRecoveryInfo    ' ensure the BracketOrder is recorded before
                    ' doing the state change, which will cause
                    ' the orders to be recorded
mEntryOrder.SaveRecoveryInfo
If Not mStopLossOrder Is Nothing Then mStopLossOrder.SaveRecoveryInfo
If Not mTargetOrder Is Nothing Then mTargetOrder.SaveRecoveryInfo

handleStimulus OpStimuli.StimExecute
If mSummary.RolloverDate <> 0 Then setRolloverTLI

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub Finish()
Const ProcName As String = "Finish"
On Error GoTo Err

Set mDataSource = Nothing
Set mOrderContext = Nothing
Set mOrderSubmitter = Nothing
If Not mEntryOrder Is Nothing Then mEntryOrder.Finish
If Not mStopLossOrder Is Nothing Then mStopLossOrder.Finish
If Not mTargetOrder Is Nothing Then mTargetOrder.Finish
If Not mCloseoutOrder Is Nothing Then mCloseoutOrder.Finish

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub Initialise( _
                ByVal pKey As String, _
                ByVal pRecoveryContextName As String, _
                ByVal pGroupName As String, _
                ByVal pOrderContext As OrderContext, _
                ByVal pContract As IContract, _
                ByVal pOrderSubmitter As IOrderSubmitter, _
                ByVal pDataSource As IMarketDataSource, _
                ByVal pIsSimulated As Boolean)
Const ProcName As String = "Initialise"
On Error GoTo Err

mSummary.Key = pKey
mRecoveryContextName = pRecoveryContextName
mSummary.GroupName = pGroupName
Set mOrderContext = pOrderContext
mSummary.ContextName = mOrderContext.Name
Set mContract = pContract
Set mDataSource = pDataSource
Set mOrderSubmitter = pOrderSubmitter
mIsSimulated = pIsSimulated

Set mTimerList = mOrderContext.TimerList
Set mClock = mTimerList.Clock

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub NotifyCloseout( _
                ByVal pExec As IExecutionReport)
Const ProcName As String = "NotifyCloseout"
On Error GoTo Err

If Size = 0 Then Exit Sub

WriteRecoveryDataComment ProcName & "()"
createCloseoutOrder

pExec.OrderId = mCloseoutOrder.Id
mCloseoutOrder.NotifyFillEx pExec, False

mSummary.RolloverDate = 0
RolloverSpecification = Nothing
SaveRecoveryInfo

fireChange BracketOrderPositionCloseoutNotified
RaiseEvent PositionCloseoutNotified
Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub RemoveBracketOrderErrorListener(ByVal pListener As IBracketOrderErrorListener)
Const ProcName As String = "RemoveBracketOrderErrorListener"
On Error GoTo Err

mBracketOrderErrorListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub RemoveBracketOrderMessageListener(ByVal pListener As IBracketOrderMsgListener)
Const ProcName As String = "RemoveBracketOrderMessageListener"
On Error GoTo Err

mBracketOrderMessageListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub RemoveChangeListener(ByVal pListener As IChangeListener)
Const ProcName As String = "RemoveChangeListener"
On Error GoTo Err

mChangeListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub RemoveExecutionListener(ByVal pListener As IExecutionListener)
Const ProcName As String = "RemoveExecutionListener"
On Error GoTo Err

mExecutionListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub RemoveStateChangeListener(ByVal pListener As IStateChangeListener)
Const ProcName As String = "RemoveStateChangeListener"
On Error GoTo Err

mStateChangeListeners.Remove pListener

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub SelfCancel(ByVal pReason As String)
gLogBracketOrderMessage "Cancel bracket order: " & pReason, _
                mDataSource, mContract, Key, mIsSimulated, Me
Cancel
fireChange BracketOrderSelfCancelled
RaiseEvent SelfCancelled
End Sub

Friend Sub SetCloseoutOrder(ByVal pOrder As Order)
Const ProcName As String = "SetCloseoutOrder"
On Error GoTo Err

Set mCloseoutOrder = pOrder
mSummary.CloseoutOrderId = mCloseoutOrder.Id

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub SetEntryOrder(ByVal pOrder As Order)
Const ProcName As String = "SetEntryOrder"
On Error GoTo Err

Assert mEntryOrder Is Nothing, Key & " Entry order already exists"

Set mEntryOrder = pOrder
mSummary.EntryOrderId = mEntryOrder.Id

mNumberOfOrders = mNumberOfOrders + 1

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewEntryLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewEntryLimitPrice"
On Error GoTo Err

setPrice mEntryOrder, _
        OrderTypeLimit Or _
            OrderTypeLimitIfTouched Or _
            OrderTypeLimitOnClose Or _
            OrderTypeLimitOnOpen Or _
            OrderTypeStopLimit Or _
            OrderTypeTrailLimit, _
        mNewEntryLimitPriceSpec, _
        pPriceSpec, _
        "entry limit price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewEntryTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewEntryTriggerPrice"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setPrice mEntryOrder, _
        OrderTypeLimitIfTouched Or _
            OrderTypeMarketIfTouched Or _
            OrderTypeStop Or _
            OrderTypeStopLimit Or _
            OrderTypeTrail Or _
            OrderTypeTrailLimit, _
        mNewEntryTriggerPriceSpec, _
        pPriceSpec, _
        "entry trigger price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewOrderLimitPrice( _
                ByVal pRole As BracketOrderRoles, _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewOrderLimitPrice"
On Error GoTo Err

Select Case pRole
Case BracketOrderRoleEntry
    SetNewEntryLimitPrice pPriceSpec
Case BracketOrderRoleStopLoss
    SetNewStopLossLimitPrice pPriceSpec
Case BracketOrderRoleTarget
    SetNewTargetLimitPrice pPriceSpec
Case Else
    AssertArgument False, Key & " Invalid pRole"
End Select

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewOrderTriggerPrice( _
                ByVal pRole As BracketOrderRoles, _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewOrderTriggerPrice"
On Error GoTo Err

Select Case pRole
Case BracketOrderRoleEntry
    SetNewEntryTriggerPrice pPriceSpec
Case BracketOrderRoleStopLoss
    SetNewStopLossTriggerPrice pPriceSpec
Case BracketOrderRoleTarget
    SetNewTargetTriggerPrice pPriceSpec
Case Else
    AssertArgument False, Key & " Invalid pRole"
End Select

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewEntryQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "SetNewEntryQuantity"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setQuantity mEntryOrder, mNewEntryQuantity, pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewStopLossLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewStopLossLimitPrice"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setPrice mStopLossOrder, _
        OrderTypeLimitOnClose Or _
            OrderTypeLimitOnOpen Or _
            OrderTypeStopLimit Or _
            OrderTypeTrailLimit, _
        mNewStopLossLimitPriceSpec, _
        pPriceSpec, _
        "stop loss limit price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewStopLossQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "SetNewStopLossQuantity"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setQuantity mStopLossOrder, mNewStopLossQuantity, pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewStopLossTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewStopLossTriggerPrice"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setPrice mStopLossOrder, _
        OrderTypeStop Or _
            OrderTypeStopLimit Or _
            OrderTypeTrail Or _
            OrderTypeTrailLimit, _
        mNewStopLossTriggerPriceSpec, _
        pPriceSpec, _
        "stop loss trigger price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewTargetLimitPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewTargetLimitPrice"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setPrice mTargetOrder, _
        OrderTypeLimit Or _
            OrderTypeLimitIfTouched Or _
            OrderTypeLimitOnClose Or _
            OrderTypeLimitOnOpen, _
        mNewTargetLimitPriceSpec, _
        pPriceSpec, _
        "target limit price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewTargetQuantity(ByVal pNewQuantity As BoxedDecimal)
Const ProcName As String = "SetNewTargetQuantity"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setQuantity mTargetOrder, mNewTargetQuantity, pNewQuantity

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Sub SetNewTargetTriggerPrice( _
                ByVal pPriceSpec As PriceSpecifier)
Const ProcName As String = "SetNewTargetTriggerPrice"
On Error GoTo Err

WriteRecoveryDataComment ProcName & "()"
setPrice mTargetOrder, _
        OrderTypeLimitIfTouched Or _
            OrderTypeMarketIfTouched, _
        mNewTargetTriggerPriceSpec, _
        pPriceSpec, _
        "target trigger price"

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub SetSize(ByVal Value As BoxedDecimal)
Const ProcName As String = "SetSize"
On Error GoTo Err

mSummary.Size = Value

If Value <> 0 Then
    mStateEngine.SetConditions OpConditions.CondSizeNonZero
Else
    mStateEngine.ClearConditions OpConditions.CondSizeNonZero
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub SetStopLossOrder(ByVal pOrder As Order)
Const ProcName As String = "SetStopLossOrder"
On Error GoTo Err

Assert mStopLossOrder Is Nothing, Key & " stop-loss order already exists"

mNumberOfOrders = mNumberOfOrders + 1
Set mStopLossOrder = pOrder
mSummary.StopLossOrderId = mStopLossOrder.Id

mStateEngine.SetConditions OpConditions.CondStopOrderExists
mStateEngine.ClearConditions OpConditions.CondStopOrderCancelled

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Friend Sub SetTargetOrder(ByVal pOrder As Order)
Const ProcName As String = "SetTargetOrder"
On Error GoTo Err

Assert mTargetOrder Is Nothing, Key & " Target order already exists"

mNumberOfOrders = mNumberOfOrders + 1
Set mTargetOrder = pOrder
mSummary.TargetOrderId = mTargetOrder.Id

mStateEngine.SetConditions OpConditions.CondTargetOrderExists
mStateEngine.ClearConditions OpConditions.CondTargetOrderCancelled

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Public Function ToString() As String
Const ProcName As String = "ToString"
On Error GoTo Err

ToString = gBracketOrderToString(Me)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Public Sub Update()
Const ProcName As String = "Update"
On Error GoTo Err

Select Case mStateEngine.State
Case BracketOrderStates.BracketOrderStateCreated
Case BracketOrderStates.BracketOrderStateSubmitted
Case BracketOrderStates.BracketOrderStateCancelling
    Exit Sub
Case Else
    Assert False, Key & " Action not allowed in state " & mStateEngine.State
End Select

Dim updateEntry As Boolean
Dim updateStop As Boolean
Dim updateTarget As Boolean
checkForPendingUpdates updateEntry, updateStop, updateTarget

If (Not updateEntry) And (Not updateStop) And (Not updateTarget) Then
    ' no updates to Action
    Exit Sub
End If

gLogBracketOrderMessage "Update bracket order: " & vbCrLf & _
                ToString, _
                mDataSource, mContract, Key, mIsSimulated, Me

If State <> BracketOrderStateCreated Then
    mOrderSubmitter.ModifyBracketOrder Me, updateEntry, updateStop, updateTarget, False
End If

Checkpoint

If updateEntry Then
    fireChange BracketOrderEntryOrderChanged
    RaiseEvent EntryOrderChanged
End If
If updateStop Then
    fireChange BracketOrderStopLossOrderChanged
    RaiseEvent StopLossOrderChanged
End If
If updateTarget Then
    fireChange BracketOrderTargetOrderChanged
    RaiseEvent TargetOrderChanged
End If
fireChange BracketOrderChangeTypes.BracketOrderChangesApplied
RaiseEvent ChangesApplied

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

'@================================================================================
' Helper Functions
'@================================================================================

Private Function CancelCloseoutOrder()
Const ProcName As String = "CancelCloseoutOrder"
On Error GoTo Err

If mCloseoutOrder Is Nothing Then Exit Function
Select Case mCloseoutOrder.Status
Case OrderStatuses.OrderStatusCreated
    mCloseoutOrder.Status = OrderStatuses.OrderStatusCancelled
    mCloseoutOrder.SaveRecoveryInfo
Case OrderStatuses.OrderStatusFilled, _
        OrderStatuses.OrderStatusCancelling, _
        OrderStatuses.OrderStatusCancelled
Case Else
    gLogOrderMessage "Cancel order", _
                    mCloseoutOrder, mDataSource, mContract, Key, mIsSimulated, Me
    mOrderSubmitter.CancelCloseoutOrder Me
End Select

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function cancelOrders() As Boolean
Const ProcName As String = "cancelOrders"
On Error GoTo Err

mSummary.CancelPrice = 0
If Not mCancelTLI Is Nothing Then
    mCancelTLI.Cancel
    Set mCancelTLI = Nothing
End If

Dim lNeedCancel As Boolean

Select Case mEntryOrder.Status
Case OrderStatuses.OrderStatusCreated
    CancelAfter = 0
    CancelTime = 0
    mEntryOrder.Status = OrderStatuses.OrderStatusCancelled
    mEntryOrder.SaveRecoveryInfo
Case Else
    lNeedCancel = True
End Select

If Not mStopLossOrder Is Nothing Then
    Select Case mStopLossOrder.Status
    Case OrderStatuses.OrderStatusCreated
        mStopLossOrder.Status = OrderStatuses.OrderStatusCancelled
        mStopLossOrder.SaveRecoveryInfo
    Case Else
        lNeedCancel = True
    End Select
End If

If Not mTargetOrder Is Nothing Then
    Select Case mTargetOrder.Status
    Case OrderStatuses.OrderStatusCreated
        mTargetOrder.Status = OrderStatuses.OrderStatusCancelled
        mTargetOrder.SaveRecoveryInfo
    Case Else
        lNeedCancel = True
    End Select
End If

If Not lNeedCancel Then Exit Function
If Not mOrderSubmitter.CancelBracketOrder(Me) Then Exit Function

cancelOrders = True

Dim StopLossOrderId As String
If Not mStopLossOrder Is Nothing Then StopLossOrderId = mStopLossOrder.Id

Dim TargetOrderId As String
If Not mTargetOrder Is Nothing Then TargetOrderId = mTargetOrder.Id
gLogBracketOrderMessage "Cancel orders: " & _
                    EntryOrder.Id & _
                    ", " & StopLossOrderId & _
                    ", " & TargetOrderId, _
                mDataSource, mContract, Key, mIsSimulated, Me

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName

End Function

Private Function cancelStateTimeout()
Const ProcName As String = "cancelStateTimeout"
On Error GoTo Err

mStateTimeoutTLI.Cancel

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function CancelStopOrder()
Const ProcName As String = "CancelStopOrder"
On Error GoTo Err

If mStopLossOrder Is Nothing Then Exit Function
Select Case mStopLossOrder.Status
Case OrderStatuses.OrderStatusCreated
    mStopLossOrder.Status = OrderStatuses.OrderStatusCancelled
    mStopLossOrder.SaveRecoveryInfo
Case OrderStatuses.OrderStatusFilled, _
    OrderStatuses.OrderStatusCancelling, _
    OrderStatuses.OrderStatusCancelled
Case Else
    gLogOrderMessage "Cancel order", _
                    mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
    mOrderSubmitter.CancelStopOrder Me
End Select

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function CancelTargetOrder()
Const ProcName As String = "CancelTargetOrder"
On Error GoTo Err

If mTargetOrder Is Nothing Then Exit Function
Select Case mTargetOrder.Status
Case OrderStatuses.OrderStatusCreated
    mTargetOrder.Status = OrderStatuses.OrderStatusCancelled
    mTargetOrder.SaveRecoveryInfo
Case OrderStatuses.OrderStatusFilled, _
    OrderStatuses.OrderStatusCancelling, _
    OrderStatuses.OrderStatusCancelled
Case Else
    gLogOrderMessage "Cancel order", _
                    mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
    mOrderSubmitter.CancelTargetOrder Me
End Select

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub checkAllOrdersComplete()
Const ProcName As String = "checkAllOrdersComplete"
On Error GoTo Err

If IsComplete Then Exit Sub

If Not mEntryOrder Is Nothing Then
    If mEntryOrder.IsActive Then Exit Sub
End If

If Not mStopLossOrder Is Nothing Then
    If mStopLossOrder.IsActive Then Exit Sub
End If

If Not mTargetOrder Is Nothing Then
    If mTargetOrder.IsActive Then Exit Sub
End If

If Not mCloseoutOrder Is Nothing Then
    If mCloseoutOrder.IsActive Then Exit Sub
End If

handleStimulus OpStimuli.StimAllOrdersComplete

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName

End Sub

Private Sub checkForPendingUpdates( _
                ByRef updateEntry As Boolean, _
                ByRef updateStop As Boolean, _
                ByRef updateTarget As Boolean)
Const ProcName As String = "checkForPendingUpdates"
On Error GoTo Err

updateEntry = checkForPendingEntryUpdates
updateStop = checkForPendingStoplossUpdates
updateTarget = checkForPendingTargetUpdates

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function checkForPendingEntryUpdates() As Boolean
Const ProcName As String = "checkForPendingEntryUpdates"
On Error GoTo Err

If mEntryOrder Is Nothing Then Exit Function

If mEntryOrder.IsDirty Then checkForPendingEntryUpdates = True

If mNewEntryQuantity Is Nothing Then
ElseIf mNewEntryQuantity <> mEntryOrder.Quantity Then
    Assert mEntryOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change Size - order " & EntryOrder.Id & " already filled"
    mEntryOrder.Quantity = mNewEntryQuantity
    checkForPendingEntryUpdates = True
End If
Set mNewEntryQuantity = Nothing

If mNewEntryLimitPriceSpec.IsValid And _
    (Not mNewEntryLimitPriceSpec.Equals(mEntryOrder.LimitPriceSpec)) _
Then
    Assert mEntryOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change entry limit price - order " & mEntryOrder.Id & " already filled"
    mEntryOrder.LimitPriceSpec = mNewEntryLimitPriceSpec
    mEntryOrder.LimitPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewEntryLimitPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingEntryUpdates = True
End If
Set mNewEntryLimitPriceSpec = gNewPriceSpecifier

If mNewEntryTriggerPriceSpec.IsValid And _
    (Not mNewEntryTriggerPriceSpec.Equals(mEntryOrder.TriggerPriceSpec)) _
Then
    Assert mEntryOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change entry trigger Price - order " & mEntryOrder.Id & " already filled"
    mEntryOrder.TriggerPriceSpec = mNewEntryTriggerPriceSpec
    mEntryOrder.TriggerPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewEntryTriggerPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingEntryUpdates = True
End If
Set mNewEntryTriggerPriceSpec = gNewPriceSpecifier

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function checkForPendingStoplossUpdates() As Boolean
Const ProcName As String = "checkForPendingStoplossUpdates"
On Error GoTo Err

If mStopLossOrder Is Nothing Then Exit Function

If mStopLossOrder.IsDirty Then checkForPendingStoplossUpdates = True
If mNewStopLossLimitPriceSpec.IsValid And _
    (Not mNewStopLossLimitPriceSpec.Equals(mStopLossOrder.LimitPriceSpec)) _
Then
    Assert mStopLossOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change stop-loss limit price - order " & mStopLossOrder.Id & " already filled"
    Assert mStopLossOrder.Status <> OrderStatuses.OrderStatusSubmitted, Key & " Can't change stop-loss limit price - order " & mStopLossOrder.Id & " already submitted"
    mStopLossOrder.LimitPriceSpec = mNewStopLossLimitPriceSpec
    mStopLossOrder.LimitPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewStopLossLimitPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingStoplossUpdates = True
End If
Set mNewStopLossLimitPriceSpec = gNewPriceSpecifier

If mNewStopLossQuantity Is Nothing Then
ElseIf mNewStopLossQuantity <> mStopLossOrder.Quantity Then
    Assert mStopLossOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change stop-loss quantity - order " & mStopLossOrder.Id & " already filled"
    mStopLossOrder.Quantity = mNewStopLossQuantity
    checkForPendingStoplossUpdates = True
End If
Set mNewStopLossQuantity = Nothing

If mNewStopLossTriggerPriceSpec.IsValid And _
    (Not mNewStopLossTriggerPriceSpec.Equals(mStopLossOrder.TriggerPriceSpec)) _
Then
    Assert mStopLossOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change stop-loss trigger price - order " & mEntryOrder.Id & " already filled"
    mStopLossOrder.TriggerPriceSpec = mNewStopLossTriggerPriceSpec
    mStopLossOrder.TriggerPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewStopLossTriggerPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingStoplossUpdates = True
End If
Set mNewStopLossTriggerPriceSpec = gNewPriceSpecifier

If orderRequiresDelayedPriceResolution(mStopLossOrder) Then checkForPendingStoplossUpdates = False

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function checkForPendingTargetUpdates() As Boolean
Const ProcName As String = "checkForPendingTargetUpdates"
On Error GoTo Err

If mTargetOrder Is Nothing Then Exit Function

If mTargetOrder.IsDirty Then checkForPendingTargetUpdates = True
If mNewTargetLimitPriceSpec.IsValid And _
    (Not mNewTargetLimitPriceSpec.Equals(mTargetOrder.LimitPriceSpec)) _
Then
    Assert mTargetOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change target limit price - order " & mTargetOrder.Id & " already filled"
    mTargetOrder.LimitPriceSpec = mNewTargetLimitPriceSpec
    mTargetOrder.LimitPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewTargetLimitPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingTargetUpdates = True
End If
Set mNewTargetLimitPriceSpec = gNewPriceSpecifier

If mNewTargetQuantity Is Nothing Then
ElseIf mNewTargetQuantity <> mTargetOrder.Quantity Then
    Assert mTargetOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change target quantity - order " & mTargetOrder.Id & " already filled"
    mTargetOrder.Quantity = mNewTargetQuantity
    checkForPendingTargetUpdates = True
End If
Set mNewTargetQuantity = Nothing

If mNewTargetTriggerPriceSpec.IsValid And _
    (Not mNewTargetTriggerPriceSpec.Equals(mTargetOrder.TriggerPriceSpec)) _
Then
    Assert mTargetOrder.Status <> OrderStatuses.OrderStatusFilled, Key & " Can't change target trigger price - order " & mEntryOrder.Id & " already filled"
    mTargetOrder.TriggerPriceSpec = mNewTargetTriggerPriceSpec
    mTargetOrder.TriggerPrice = mOrderContext.CalculateOffsettedPrice( _
                                                mNewTargetTriggerPriceSpec, _
                                                mContract.Specifier.SecType, _
                                                mEntryOrder.Action)
    checkForPendingTargetUpdates = True
End If
Set mNewTargetTriggerPriceSpec = gNewPriceSpecifier

If orderRequiresDelayedPriceResolution(mTargetOrder) Then checkForPendingTargetUpdates = False

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function CreateAnOrder(ByVal pId As String) As IOrder
Const ProcName As String = "CreateAnOrder"
On Error GoTo Err

Dim lOrder As IOrder
Set lOrder = mOrderContext.CreateRawOrder(pId, mRecoveryContextName)


lOrder.Initialise mSummary.GroupName, mContract.Specifier, mOrderContext
Set CreateAnOrder = lOrder

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub createCloseoutOrder()
Const ProcName As String = "createCloseoutOrder"
On Error GoTo Err

Dim lOrder As Order

If mSummary.CloseoutSpecifier Is Nothing Then
    Set lOrder = mOrderContext.NewOrder(OrderTypes.OrderTypeMarket, mRecoveryContextName)
    lOrder.DontCheckAttributeModificationPermitted = True
Else
    With mSummary.CloseoutSpecifier
        Set lOrder = mOrderContext.NewOrder(.OrderType, mRecoveryContextName)
        lOrder.DontCheckAttributeModificationPermitted = True
        lOrder.LimitPriceSpec = .LimitPriceSpec
        lOrder.TriggerPriceSpec = .TriggerPriceSpec
        lOrder.IgnoreRegularTradingHours = .OutsideRTH
    End With
End If
mOrderContext.FixupEntryOrder lOrder

lOrder.Action = IIf(LongPosition, OrderActions.OrderActionSell, OrderActions.OrderActionBuy)
lOrder.Quantity = CreateBoxedDecimal(Abs(Size))
lOrder.TimeInForce = OrderTIFs.OrderTIFGoodTillCancelled
lOrder.DontCheckAttributeModificationPermitted = False

SetCloseoutOrder lOrder

SaveRecoveryInfo

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function doActions( _
                ByRef pActions() As OpActions, _
                ByVal pPreviousState As BracketOrderStates, _
                ByVal pStimulus As OpStimuli) As Variant
Const ProcName As String = "doActions"
On Error GoTo Err

Dim lAction As Variant
For Each lAction In pActions
    Select Case CLng(lAction)
    Case SpecialActions.NoAction
    Case OpActions.ActPlaceOrders
        doActions = placeOrders
    Case OpActions.ActCancelOrders
        doActions = cancelOrders
    Case OpActions.ActCancelStopOrder
        doActions = CancelStopOrder
    Case OpActions.ActCancelTargetOrder
        doActions = CancelTargetOrder
    Case OpActions.ActResubmitStopOrder
        doActions = ResubmitStopOrder
    Case OpActions.ActResubmitTargetOrder
        doActions = ResubmitTargetOrder
    Case OpActions.ActResubmitStopAndTargetOrders
        doActions = ResubmitStopAndTargetOrders
    Case OpActions.ActPlaceCloseoutOrder
        doActions = placeCloseoutOrder
    Case OpActions.ActCompletionActions
        doActions = doCompletionActions
    Case OpActions.ActAlarm
        ' need to put something in here
    Case OpActions.ActSetTimeout
        doActions = setStateTimeout
    Case OpActions.ActCancelTimeout
        doActions = cancelStateTimeout
    Case OpActions.ActLog
        gLog "Stimulus '" & gOpStimuliToString(pStimulus) & "' occurred in state " & gBracketOrderStatesToString(pPreviousState) & " (" & mSummary.Key & ")", ProcName, ModuleName, , LogLevelSevere
        doActions = Empty
    Case OpActions.ActCancelCloseoutOrder
        doActions = CancelCloseoutOrder
    Case OpActions.ActResubmitCloseoutOrder
        doActions = placeDelayedCloseoutOrder
    Case Else
        Assert False, Key & " Invalid Action " & lAction
    End Select
Next

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function doCompletionActions()
Const ProcName As String = "doCompletionActions"
On Error GoTo Err

If mIsRolloverInProgress Then
    fireChange BracketOrderCompleted
    RaiseEvent Completed
ElseIf mSummary.RolloverDate <> 0 Then
    fireChange BracketOrderRolloverPending
ElseIf mOrderContext Is Nothing Then
    fireChange BracketOrderCompleted
    RaiseEvent Completed
Else    'If mOrderContext.Name <> BalancingOrderContextName Then
    mOrderContext.NotifyBracketOrderClosed Me
    fireChange BracketOrderCompleted
    RaiseEvent Completed
End If


Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub fireBracketOrderError( _
                ByVal pOrder As IOrder, _
                ByVal pErrorCode As Long, _
                ByVal pErrorMsg As String)
Const ProcName As String = "fireBracketOrderError"
On Error GoTo Err

Dim ev As BracketOrderErrorEventData
Set ev.Source = Me
Set ev.AffectedOrder = pOrder
ev.ErrorCode = pErrorCode
ev.ErrorMsg = pErrorMsg

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mBracketOrderErrorListeners.Valid Then
    sInit = True
    sSomeListeners = mBracketOrderErrorListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IBracketOrderErrorListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.NotifyBracketOrderError ev
    Next
End If

RaiseEvent OrderError(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fireBracketOrderMessage( _
                ByVal pOrder As IOrder, _
                ByVal pMessage As String)
Const ProcName As String = "fireBracketOrderMessage"
On Error GoTo Err

Dim ev As BracketOrderMessageEventData
Set ev.Source = Me
Set ev.AffectedOrder = pOrder
ev.Message = pMessage

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mBracketOrderMessageListeners.Valid Then
    sInit = True
    sSomeListeners = mBracketOrderMessageListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IBracketOrderMsgListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.NotifyBracketOrderMessage ev
    Next
End If

RaiseEvent OrderMessage(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fireChange( _
                ByVal pChangeType As BracketOrderChangeTypes)
Const ProcName As String = "fireChange"
On Error GoTo Err

Dim ev As ChangeEventData
Set ev.Source = Me
ev.changeType = pChangeType

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mChangeListeners.Valid Then
    sInit = True
    sSomeListeners = mChangeListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IChangeListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.Change ev
    Next
End If

RaiseEvent Change(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fireExecution( _
                ByVal pExec As IExecutionReport)
Const ProcName As String = "fireExecution"
On Error GoTo Err

Dim ev As ExecutionEventData
Set ev.Source = Me
Set ev.ExecutionReport = pExec

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mExecutionListeners.Valid Then
    sInit = True
    sSomeListeners = mExecutionListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IExecutionListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.NotifyExecution ev
    Next
End If

RaiseEvent Execution(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fireStateChange( _
                ByVal pState As BracketOrderStates)
Const ProcName As String = "fireStateChange"
On Error GoTo Err

Dim ev As StateChangeEventData
Set ev.Source = Me
ev.State = pState

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mStateChangeListeners.Valid Then
    sInit = True
    sSomeListeners = mStateChangeListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IStateChangeListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.Change ev
    Next
End If

RaiseEvent StateChange(ev)

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Sub fireRecoveryDataChanged()
Const ProcName As String = "fireRecoveryDataChanged"
On Error GoTo Err

Dim ev As RecoveryDataChangedEventData
Set ev.Source = Me

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mRecoverableObjectListeners.Valid Then
    sInit = True
    sSomeListeners = mRecoverableObjectListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IRecoverableObjectListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.NotifyRecoveryDataChanged ev
    Next
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function handleStimulus(ByVal pStimulus As OpStimuli) As Variant
Const ProcName As String = "handleStimulus"
On Error GoTo Err

Dim lPrevState As BracketOrderStates
lPrevState = mStateEngine.State

Dim lConditions As OpConditions
lConditions = mStateEngine.Conditions

Dim s As String
s = "Handling bracket order stimulus (" & mSummary.Key & "): " & vbCrLf & _
    "    prior state=" & gBracketOrderStatesToString(lPrevState) & _
    "; stimulus=" & gOpStimuliToString(pStimulus) & _
    "; conditions=" & gOpConditionsToString(lConditions)

Dim lActions() As OpActions
lActions = mStateEngine.NotifyStimulus(pStimulus)
mSummary.State = State
SaveRecoveryInfo

Dim lActionsString As String
Dim i As Long
For i = 0 To UBound(lActions)
    lActionsString = lActionsString & gOpActionsToString(lActions(i)) & IIf(i = UBound(lActions), "", ",")
Next

gLog s & "; new state=" & gBracketOrderStatesToString(mStateEngine.State) & _
        "; actions=" & lActionsString, _
        ProcName, ModuleName

handleStimulus = doActions(lActions, lPrevState, pStimulus)
If State <> lPrevState Then
    fireChange BracketOrderChangeTypes.BracketOrderStateChanged
    fireStateChange mStateEngine.State
End If

Exit Function

Err:
Dim lErr As Long: lErr = Err.Number
Dim lDesc As String: lDesc = Err.Description
gLog s, ProcName, ModuleName
gHandleUnexpectedError ProcName, ModuleName, pErrorNumber:=lErr, pErrorDesc:=lDesc
End Function

Private Sub initiateRollover()
Const ProcName As String = "initiateRollover"
On Error GoTo Err

If Not mRolloverController Is Nothing Then Exit Sub

Set mRolloverController = New RolloverController
mRolloverController.Initialise Me, mOrderContext.OrderManager, mOrderContext.ScopeName, mTimerList
WriteRecoveryDataComment ProcName & "()"
StartTask mRolloverController, PriorityNormal
mRolloverController.AddStateChangeListener Me

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function hasPeggedOrder(ByVal pOrder As IOrder) As Boolean
If pOrder Is Nothing Then Exit Function
If pOrder.Status <> OrderStatuses.OrderStatusCreated Then Exit Function
If Not orderRequiresDelayedPriceResolution(pOrder) Then Exit Function
hasPeggedOrder = True
End Function

Private Function orderRequiresDelayedPriceResolution(ByVal pOrder As IOrder) As Boolean
If pOrder.LimitPriceSpec Is Nothing Then
    orderRequiresDelayedPriceResolution = pOrder.TriggerPriceSpec.RequiresDelayedPriceResolution
ElseIf pOrder.TriggerPriceSpec Is Nothing Then
    orderRequiresDelayedPriceResolution = pOrder.LimitPriceSpec.RequiresDelayedPriceResolution
Else
    orderRequiresDelayedPriceResolution = pOrder.LimitPriceSpec.RequiresDelayedPriceResolution Or _
                                        pOrder.TriggerPriceSpec.RequiresDelayedPriceResolution
End If
End Function

Private Function placeCloseoutOrder()
Const ProcName As String = "placeCloseoutOrder"
On Error GoTo Err

createCloseoutOrder

fireChange BracketOrderCloseoutOrderCreated
RaiseEvent CloseoutOrderCreated

mStateEngine.SetConditions OpConditions.CondCloseoutOrderExists

mOrderSubmitter.ModifyBracketOrder Me, False, False, False, True

If mSummary.CloseoutSpecifier Is Nothing Then
ElseIf mSummary.CloseoutSpecifier.ForceCloseAfterSecs <> 0 Then
    Set mForceCloseTLI = mTimerList.Add( _
                                    Nothing, _
                                    mSummary.CloseoutSpecifier.ForceCloseAfterSecs)
End If
                            
Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function placeDelayedCloseoutOrder()
Const ProcName As String = "placeDelayedCloseoutOrder"
On Error GoTo Err

Set mDelayedCloseoutTLI = mTimerList.Add( _
                                Nothing, _
                                15)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function placeOrders()
Const ProcName As String = "placeOrders"
On Error GoTo Err

mOrderSubmitter.ExecuteBracketOrder Me

Checkpoint

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function placePeggedOrder( _
                ByVal pOrder As IOrder, _
                ByVal pRole As BracketOrderRoles) As Boolean
Const ProcName As String = "placePeggedOrder"
On Error GoTo Err

If Not hasPeggedOrder(pOrder) Then Exit Function
If Not (mOrderContext.IsReadyForPriceSpecifier(pOrder.LimitPriceSpec) And _
        mOrderContext.IsReadyForPriceSpecifier(pOrder.TriggerPriceSpec) And _
        mOrderContext.IsReadyForOrderType(pOrder.OrderType)) Then
    mOrderContext.AddChangeListener Me
    Exit Function
End If

' the stop-loss limit and/or trigger price are to be pegged to the entry price

If pRole = BracketOrderRoleStopLoss Then
    gLog "Updating pegged StopLoss order for " & mSummary.Key, ProcName, ModuleName
    
    If Abs(mSummary.Size) <> pOrder.Quantity Then SetNewStopLossQuantity CreateBoxedDecimal(Abs(mSummary.Size))
    
    If pOrder.LimitPriceSpec Is Nothing Then
    ElseIf pOrder.LimitPriceSpec.PriceType = PriceValueTypeEntry Then
        SetNewStopLossLimitPrice gNewPriceSpecifier(EntryOrder.LastFillPrice, _
                                                    "", _
                                                    PriceValueTypeValue, _
                                                    pOrder.LimitPriceSpec.Offset, _
                                                    pOrder.LimitPriceSpec.OffsetType)
    End If
    If pOrder.TriggerPriceSpec Is Nothing Then
    ElseIf pOrder.TriggerPriceSpec.PriceType = PriceValueTypeEntry Then
        SetNewStopLossTriggerPrice gNewPriceSpecifier(EntryOrder.LastFillPrice, _
                                                    "", _
                                                    PriceValueTypeValue, _
                                                    pOrder.TriggerPriceSpec.Offset, _
                                                    pOrder.TriggerPriceSpec.OffsetType)
    End If
Else
    gLog "Updating pegged Target order for " & mSummary.Key, ProcName, ModuleName
    
    If Abs(mSummary.Size) <> pOrder.Quantity Then SetNewTargetQuantity CreateBoxedDecimal(Abs(mSummary.Size))
    
    If pOrder.LimitPriceSpec Is Nothing Then
    ElseIf pOrder.LimitPriceSpec.PriceType = PriceValueTypeEntry Then
        SetNewTargetLimitPrice gNewPriceSpecifier(EntryOrder.LastFillPrice, _
                                                    "", _
                                                    PriceValueTypeValue, _
                                                    pOrder.LimitPriceSpec.Offset, _
                                                    pOrder.LimitPriceSpec.OffsetType)
    End If
    If pOrder.TriggerPriceSpec Is Nothing Then
    ElseIf pOrder.TriggerPriceSpec.PriceType = PriceValueTypeEntry Then
        SetNewTargetTriggerPrice gNewPriceSpecifier(EntryOrder.LastFillPrice, _
                                                    "", _
                                                    PriceValueTypeValue, _
                                                    pOrder.TriggerPriceSpec.Offset, _
                                                    pOrder.TriggerPriceSpec.OffsetType)
    End If
End If

placePeggedOrder = True

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function placePeggedOrders() As Boolean
Const ProcName As String = "placePeggedOrders"
On Error GoTo Err

If mSummary.PeggedOrdersProcessed Then
    placePeggedOrders = True
    Exit Function
End If

If Not (hasPeggedOrder(mStopLossOrder) Or hasPeggedOrder(mTargetOrder)) Then
    placePeggedOrders = True
    Exit Function
End If

If mSummary.Size = 0 Then
    placePeggedOrders = False
    Exit Function
End If

Dim lUpdated As Boolean

lUpdated = placePeggedOrder(mStopLossOrder, BracketOrderRoleStopLoss)
lUpdated = lUpdated Or placePeggedOrder(mTargetOrder, BracketOrderRoleTarget)

If lUpdated Then
    gLog "Pegged orders placed for " & mSummary.Key, ProcName, ModuleName
    mSummary.PeggedOrdersProcessed = True
    Update
    SaveRecoveryInfo
    placePeggedOrders = True
    Exit Function
End If

placePeggedOrders = False

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub processExecution( _
                ByVal pExec As Execution)
Const ProcName As String = "processExecution"
On Error GoTo Err

' Note that the Order object ensures that pExec will always
' be an Execution object, not just some other object that
' implements IExecutionReport

If mSummary.Size = 0 Then
    mSummary.StartTime = ConvertDateTzToTz(pExec.FillTime, _
                                            GetTimeZone(pExec.TimezoneName), _
                                            GetTimeZone(mContract.TimezoneName))
End If

Dim lIncrement As BoxedDecimal
Set lIncrement = pExec.Quantity.Mult(CreateBoxedDecimal(pExec.Price))

If pExec.Action = OrderActionBuy Then
    CumBuyPrice = mSummary.CumBuyPrice.Add(lIncrement)
    SetSize Size.Add(pExec.Quantity)
Else
    CumSellPrice = mSummary.CumSellPrice.Add(lIncrement)
    SetSize Size.Subtr(pExec.Quantity)
End If
    
If Size = 0 Then
    mSummary.EndTime = ConvertDateTzToTz(pExec.FillTime, _
                                        GetTimeZone(pExec.TimezoneName), _
                                        GetTimeZone(mContract.TimezoneName))
ElseIf mSummary.RolloverSpecification Is Nothing Then
ElseIf mRolloverTLI Is Nothing Then
    setRolloverTLI
End If

SaveRecoveryInfo

fireExecution pExec
fireChange BracketOrderChangeTypes.BracketOrderSizeChanged
RaiseEvent SizeChanged

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function ResubmitStopOrder()
Const ProcName As String = "resubmitStopOrder"
On Error GoTo Err

gLogOrderMessage "Resubmit stop-loss order", _
                mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
mOrderSubmitter.ResubmitStopOrder Me
mStateEngine.ClearConditions OpConditions.CondStopOrderCancelled

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Function ResubmitStopAndTargetOrders()
Const ProcName As String = "resubmitStopAndTargetOrders"
On Error GoTo Err

gLogOrderMessage "Resubmit stop-loss order", _
                mStopLossOrder, mDataSource, mContract, Key, mIsSimulated, Me
gLogOrderMessage "Resubmit target order", _
                mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
mOrderSubmitter.ResubmitStopAndTargetOrders Me
mStateEngine.ClearConditions OpConditions.CondStopOrderCancelled
mStateEngine.ClearConditions OpConditions.CondTargetOrderCancelled

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName

End Function

Private Function ResubmitTargetOrder()
Const ProcName As String = "resubmitTargetOrder"
On Error GoTo Err

gLogOrderMessage "Resubmit target order", _
                mTargetOrder, mDataSource, mContract, Key, mIsSimulated, Me
mOrderSubmitter.ResubmitTargetOrder Me
mStateEngine.ClearConditions OpConditions.CondTargetOrderCancelled

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub SaveRecoveryInfo()
Const ProcName As String = "SaveRecoveryInfo"
On Error GoTo Err

If mIsSimulated Then Exit Sub
If Not mSummary.IsDirty Then Exit Sub

If mRecoverableObjectListeners Is Nothing Or mRecoverableObjectListeners.Count = 0 Then Exit Sub

fireRecoveryDataChanged

mSummary.SetClean

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

''
' Set the 'dirty' flag, and raise a ChangesPending event if one has not already
' been raised.
'@/
Private Sub setDirty()
Const ProcName As String = "setDirty"
On Error GoTo Err

If mIsDirty Then Exit Sub

mIsDirty = True
fireChange BracketOrderChangeTypes.BracketOrderChangesPending
RaiseEvent ChangesPending

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub

Private Function setStateTimeout()
Const ProcName As String = "setStateTimeout"
On Error GoTo Err

Set mStateTimeoutTLI = mTimerList.Add(Empty, 1)

Exit Function

Err:
gHandleUnexpectedError ProcName, ModuleName
End Function

Private Sub WriteRecoveryDataComment(ByVal pComment As String)
Const ProcName As String = "writeRecoveryDataComment"
On Error GoTo Err

Dim ev As RecoveryDataCommentEventData
Set ev.Source = Me
ev.Comment = mSummary.Key & ":" & pComment

Static sInit As Boolean
Static sCurrentListeners() As Object
Static sSomeListeners As Boolean

If Not sInit Or Not mRecoverableObjectListeners.Valid Then
    sInit = True
    sSomeListeners = mRecoverableObjectListeners.GetCurrentListeners(sCurrentListeners)
End If
If sSomeListeners Then
    Dim lListener As IRecoverableObjectListener
    Dim i As Long
    For i = 0 To UBound(sCurrentListeners)
        Set lListener = sCurrentListeners(i)
        lListener.WriteRecoveryDataComment ev
    Next
End If

Exit Sub

Err:
gHandleUnexpectedError ProcName, ModuleName
End Sub


